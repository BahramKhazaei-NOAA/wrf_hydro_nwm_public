module module_rtland
  USE module_sf_Noahlsm_wrf_input_rt
! USE module_sf_Noahlsm_param_init_rt
  USE module_Noahlsm_utility_rt
  USE module_sf_noahlsm_rt
  USE module_sf_Noahlsm_param_init_rt
  USE module_date_utilities_rt
  USE module_Noah_distr_routing
  USE module_Noah_gw_baseflow
  USE module_Noah_channel_routing
  USE module_Noah_chan_param_init_rt

#ifdef MPP_LAND
  USE module_mpp_land
#endif
#ifdef COUPLED 
  USE MODULE_CPL_LAND_WRF 
#endif

  IMPLICIT NONE


  ! Dummy parameterized dimension for maximum number of soil levels allowed
  INTEGER, PARAMETER :: NSOLDX = 100

  ! ZSOIL, set through the namelist, is the BOTTOM of each soil layer (m)
!  REAL, DIMENSION(NSOLDX) :: ZSOIL

  REAL :: T1V,TH2V

!-----------------------------------------------------------------
!  Dimensions from the input file:
!-----------------------------------------------------------------

!     IX: x-direction points, usually along latitude
!     JX: y-direction points, usually along longitude
  INTEGER :: IX
  INTEGER :: JX
  INTEGER :: LAND_CAT
  INTEGER :: SOIL_CAT

!-----------------------------------------------------------------
!  DECLARE VARIABLES FOR GRIDDED SIMULATION
!-----------------------------------------------------------------

! the following parameters are read from a namelist file

! setup model configuration
!   KHOUR: number of hours for the simulation
  INTEGER :: KHOUR
  INTEGER :: KDAY
  INTEGER :: HHTIME,MMTIME ! Real times for solar rad. calculations
! INTEGER :: NSOIL: number of soil layers for the LSM integration
! REAL    :: DT:    time-step in seconds
! REAL    :: ZLVL:  Level (m) at which atmospheric fields are taken to be valid
  INTEGER :: FORC_TYP   ! Type of forcing data specified in namelist file
  INTEGER :: RSTRT_SWC  ! Switch for resetting restart accumulation vars = 0. (0-no, 1-yes)
  INTEGER :: SNOW_ASSIM ! Switch for snow assimilation
  INTEGER :: TERADJ_SOLAR ! Switch for terrain adjustment of incoming solar radiation
  INTEGER :: HIRES_OUT  ! Switch for output routing grid data
  INTEGER :: KCOWS ! Time level counter for COWS simulation...
  CHARACTER(len=3)         :: DOY   !COWS Julian day for filename...
  CHARACTER(len=256)       :: product   ! spec. pcp. product (see FORC_TYP 5)
  CHARACTER(len=256)       :: dat_dir   ! data directory for alternate soil/veg
  integer istatus


! Unaccounted for variables when compiling w/ implicit none F90

!KWM  REAL   :: VEGMIN,VEGMAX
  REAL   :: SNOFAC,ALBED
  REAL   :: RHO,CHKFF,T14,AET,FUP,S
!KWM  REAL   :: F, H
!KWM  REAL   :: SNOFLX, SNMAX, SNOEVP

  INTEGER   :: i,j,k,ns,ierr,kx
  real :: Z

!DJG_DES  Month checks for GREENFAC and ALBEDO12M input
  INTEGER :: MM
  INTEGER :: DD 
  INTEGER :: DD_chk

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Gridded fields
#ifdef COUPLED 
  REAL,    allocatable, DIMENSION(:,:,:)   :: out_cpl
#endif
  INTEGER, allocatable, DIMENSION(:,:)   :: VEGTYP,SOLTYP
  REAL,    allocatable, DIMENSION(:,:)   :: TERRAIN, LATITUDE, LONGITUDE
  REAL,    allocatable, DIMENSION(:,:)   :: T2,XLONG,U,V,PRES,SHORT,PRCP1
  REAL,    allocatable, DIMENSION(:,:)   :: FPAR, LAI
!DJG_DES  Assign Arrays for GREENFRAC and ALBEDO12M
  REAL,    allocatable, DIMENSION(:,:)   :: GREENFRAC, ALBEDO12M
  REAL,    allocatable, DIMENSION(:,:)   :: CMC,SNODEP,WEASD,T1, SNOWC,ZNT
  REAL,    allocatable, DIMENSION(:,:)   :: ETPX,ETAX,SOILHX,CHX,RUNOFF1X,RUNOFF2X

  REAL,    allocatable, DIMENSION(:,:)   :: LH_yw, SOILW_yw, SOILM_yw
  REAL,    allocatable, DIMENSION(:,:)   :: ETAKIN, QFX,QSFC
  REAL,    allocatable, DIMENSION(:,:)   :: RUNOFF3X,EDIRX,ECX,ETTX,SNMAXX,RCX,HX
  REAL,    allocatable, DIMENSION(:,:)   :: Q2X,SFCSPDX,ALBEDX,SMCMAX1,SMCWLT1
  REAL,    allocatable, DIMENSION(:,:)   :: SMCREF1,FX,RESX
  REAL,    allocatable, DIMENSION(:,:)   :: SNOFLXX,SNOEVPX,ACSNOM,ESNOW2D,ACRAIN,ACRAIN_0
  REAL,    allocatable, DIMENSION(:,:)   :: DRIP2D, DEWFALL, SOILMX, EMISS
  REAL,    allocatable, DIMENSION(:,:,:) :: SMC,STC,SH2OX,SICE
  REAL,    allocatable, DIMENSION(:,:,:) :: ZSOILX 
  REAL,    allocatable, DIMENSION(:,:)   :: PRCP_OUT, ZLVL_WRF, z0_wrf, TBOT_WRF
  integer ii,jj,ims, jms
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#ifdef MPP_LAND
  integer,    allocatable, DIMENSION(:,:)   :: intTmp1,intTmp2,intTmp3
#endif



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!DJG   VARIABLES FOR ROUTING
  INTEGER, allocatable, DIMENSION(:,:)      :: CH_NETRT !-- keeps track of the 0-1 channel network
  INTEGER, allocatable, DIMENSION(:,:)      :: CH_NETLNK !-- assigns a unique value to each channel gridpoint, called links
  REAL,    allocatable, DIMENSION(:,:)      :: LATVAL,LONVAL !-- lat lon
  REAL, allocatable,    DIMENSION(:)        :: CHLAT,CHLON   !  channel lat and lon
  INTEGER, allocatable, DIMENSION(:,:)      :: LAKE_MSKRT, BASIN_MSK,LAK_1K
  INTEGER, allocatable, DIMENSION(:,:)      :: g_LAK_1K
  REAL,    allocatable, DIMENSION(:,:)      :: ELRT,SOXRT,SOYRT,OVROUGHRT,RETDEPRT
  REAL,    allocatable, DIMENSION(:,:,:)    :: SO8RT
  INTEGER,    allocatable, DIMENSION(:,:,:) :: SO8RT_D, SO8LD_D
  REAL,    allocatable, DIMENSION(:,:)      :: SO8LD_Vmax
#ifdef MPP_LAND
  integer,    allocatable, DIMENSION(:,:)   :: g_tmp_int
#endif
  REAL   Vmax
  REAL,    allocatable, DIMENSION(:,:)      :: SFCHEADRT,INFXSRT,LKSAT,LKSATRT,ETPNDX
  REAL,    allocatable, DIMENSION(:,:)      :: SFCHEADSUBRT,INFXSUBRT,LKSATFAC
  REAL,    allocatable, DIMENSION(:,:)      :: QSUBRT,ZWATTABLRT,QSUBBDRYRT,SOLDEPRT
  REAL,    allocatable, DIMENSION(:,:)      :: SUB_RESID
  REAL,    allocatable, DIMENSION(:,:)      :: q_sfcflx_x,q_sfcflx_y
  REAL	  :: DXRT,DX,DTRT,GRDAREART,SUBFLORT,WATAVAILRT,QSUBDRYRT,QSUBBDRYTRT
  REAL    :: SFHEAD1RT,INFXS1RT,QSTRMVOLTRT,QBDRYTRT,SFHEADRT,ETPND1,INFXSRTOT
  REAL 	  :: LAKE_INFLOTRT,accsuminfxs,diffsuminfxs,RETDEPFRAC
  REAL    :: VERTKSAT,l3temp,l4temp,l3moist,l4moist,RNOF1TOT,RNOF2TOT,RNOF3TOT
  INTEGER :: IXRT,JXRT,AGGFACTRT,vegct
  INTEGER :: AGGFACYRT, AGGFACXRT, KRT
  INTEGER :: SATLYRCHKRT,DT_FRACRT,SUBRTSWCRT,OVRTSWCRT,CHANRTSWCRT
  INTEGER :: IXXRT, JYYRT, LAKE_CT, STRM_CT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!DJG   VARIABLES FOR GW/Baseflow
  INTEGER :: GWBASESWCRT,numbasns
  INTEGER, allocatable, DIMENSION(:,:)   :: GWSUBBASMSK  !GW basin mask grid
  REAL,    allocatable, DIMENSION(:,:)   :: qinflowbase  !strm inflow/baseflow from GW
  REAL,    allocatable, DIMENSION(:,:)   :: SOLDRAIN     !time-step drainage
  INTEGER, allocatable, DIMENSION(:,:)   :: gw_strm_msk  !GW basin mask grid
  REAL,    allocatable, DIMENSION(:)     :: z_gwsubbas   !depth in GW bucket
  REAL,    allocatable, DIMENSION(:)     :: qin_gwsubbas !flow to GW bucket
  REAL,    allocatable, DIMENSION(:)     :: qout_gwsubbas!flow from GW bucket
  REAL,    allocatable, DIMENSION(:)     :: gwbas_pix_ct !ct of strm pixels in
  REAL,    allocatable, DIMENSION(:)     :: z_q_bas_parm !GW bucket disch params
  INTEGER, allocatable, DIMENSION(:)     :: ct2_bas       !ct of lnd pixels in basn
  REAL,    allocatable, DIMENSION(:)     :: bas_pcp      !sub-basin avg'd pcp
  INTEGER                                :: bas
  CHARACTER(len=19)                      :: header
  CHARACTER(len=1)                       :: jnk
  REAL, allocatable, DIMENSION(:)        :: gw_buck_coeff,gw_buck_exp,z_max  !GW bucket parameters
!DJG Switch for Deep Sat GW Init:
  INTEGER                                :: DEEPGWSPIN  !Switch to setup run for deep GW spinp

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!DJG,DNY   VARIABLES FOR CHANNEL ROUTING
!-- channel params
  INTEGER, allocatable, DIMENSION(:)   :: LINK       !channel link
  INTEGER, allocatable, DIMENSION(:)   :: TO_NODE    !link's to node
  INTEGER, allocatable, DIMENSION(:)   :: FROM_NODE  !link's from node
  INTEGER, allocatable, DIMENSION(:)   :: ORDER      !link's order
  INTEGER, allocatable, DIMENSION(:)   :: STRMFRXSTPTS      !frxst point flag
  INTEGER, allocatable, DIMENSION(:)   :: TYPEL       !type of link Muskingum: 0 strm 1 lake 
                                                      !-- Diffusion: 0 edge or pour; 1 interior; 2 lake
  INTEGER, allocatable, DIMENSION(:)   :: TYPEN      !type of link 0 strm 1 lake
  REAL, allocatable, DIMENSION(:)      :: QLAKEI      !lake inflow in difussion scheme
  REAL, allocatable, DIMENSION(:)      :: QLAKEO      !lake outflow in difussion scheme
  INTEGER, allocatable, DIMENSION(:)   :: LAKENODE   !which nodes flow into which lakes
  REAL, allocatable, DIMENSION(:)      :: CVOL       ! channel volume

  REAL, allocatable, DIMENSION(:)      :: MUSK, MUSX !muskingum params
  REAL, allocatable, DIMENSION(:)      :: CHANLEN    !link length
  REAL, allocatable, DIMENSION(:)      :: MannN      !mannings N
  REAL, allocatable, DIMENSION(:)      :: So         !link slope
  REAL, allocatable, DIMENSION(:)      :: ChSSlp, Bw !trapezoid link params
  REAL, allocatable, DIMENSION(:,:)    :: QLINK      !flow in link
  REAL, allocatable, DIMENSION(:)      :: HLINK      !head in link
  REAL, allocatable, DIMENSION(:)      :: ZELEV      !elevation of nodes for channel
  INTEGER, allocatable, DIMENSION(:)   :: CHANXI,CHANYJ !map chan to fine grid
  REAL,  DIMENSION(50)     :: BOTWID,HLINK_INIT,CHAN_SS,CHMann !Channel parms from table

  REAL, allocatable, DIMENSION(:)      :: RESHT  !reservoir height
  REAL                                 :: RETDEP_CHAN  ! Channel retention depth
  INTEGER :: NLINKS  !maximum number of unique links in channel
  INTEGER :: NLAKES  !number of lakes
  INTEGER :: MAXORDER !maximum stream order
!-- lake params
  REAL, allocatable, DIMENSION(:)    :: HRZAREA    !horizontal extent of lake, km^2
  REAL, allocatable, DIMENSION(:)    :: LAKEMAXH   !maximum depth (m)
  REAL, allocatable, DIMENSION(:)    :: WEIRC      !coeff of overtop weir
  REAL, allocatable, DIMENSION(:)    :: WEIRL      !overtop weir length (m)
  REAL, allocatable, DIMENSION(:)    :: ORIFICEC   !coefficient of orifice
  REAL, allocatable, DIMENSION(:)    :: ORIFICEA   !orifice opening area (m^2)
  REAL, allocatable, DIMENSION(:)    :: ORIFICEE   !orifice elevation (m)
  REAL, allocatable, DIMENSION(:)    :: LATLAKE, LONLAKE,ELEVLAKE ! lake info
#ifdef MPP_LAND
  INTEGER, allocatable, DIMENSION(:)    :: lake_index,nlinks_index
  INTEGER, allocatable, DIMENSION(:,:)  :: Link_location
  integer mpp_nlinks, yw_mpp_nlinks
#endif
  
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!DJG   VARIABLES FOR AGGREGATION/DISAGGREGATION
  REAL,    allocatable, DIMENSION(:,:,:)   :: SMCRT,SMCMAXRT,SMCWLTRT,SH2OWGT
  REAL,    allocatable, DIMENSION(:,:)     :: INFXSAGGRT
  REAL,    allocatable, DIMENSION(:,:)     :: DHRT,QSTRMVOLRT,QBDRYRT,LAKE_INFLORT
  REAL,    allocatable, DIMENSION(:,:)     :: QSTRMVOLRT_TS,LAKE_INFLORT_TS
  REAL,    allocatable, DIMENSION(:,:)     :: QSTRMVOLRT_DUM,LAKE_INFLORT_DUM
  REAL,    allocatable, DIMENSION(:,:)       :: INFXSWGT, ywtmp
  REAL,    allocatable, DIMENSION(:)       :: SMCAGGRT,STCAGGRT,SH2OAGGRT
  REAL    :: INFXSAGG1RT,SFCHEADAGG1RT,SFCHEADAGGRT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!DJG   VARIABLES FOR ONLINE MASS BALANCE CALCULATION
  INTEGER, PARAMETER :: double=8
  REAL(KIND=double)    :: DCMC,DSWE,DACRAIN,DSFCEVP,DCANEVP,DEDIR,DETT,DEPND,DESNO,DSFCRNFF
  REAL(KIND=double)    :: DSMCTOT,RESID,SUMEVP,DUG1RNFF,DUG2RNFF,SMCTOT1,SMCTOT2,DETP
  REAL(KIND=double)    :: suminfxsrt,suminfxs1,suminfxs2,dprcp_ts
  REAL(KIND=double)    :: CHAN_IN1,CHAN_IN2,LAKE_IN1,LAKE_IN2,zzz, CHAN_STOR,CHAN_OUT
  REAL(KIND=double)    :: CHAN_INV,LAKE_INV  !-channel and lake inflow in volume
  REAL(KIND=double)    :: DQBDRY
  REAL    :: QSTRMVOLTRT1,LAKE_INFLOTRT1,QBDRYTOT1,LSMVOL
  REAL(KIND=double),    allocatable, DIMENSION(:)   :: DSMC,SMCRTCHK
  REAL(KIND=double),    allocatable, DIMENSION(:,:)  :: CMC_INIT,SWE_INIT
!  REAL(KIND=double),    allocatable, DIMENSION(:,:,:) :: SMC_INIT
  REAL(KIND=double)            :: SMC_INIT,SMC_FINAL,resid2,resid1
  REAL(KIND=double)            :: chcksm1,chcksm2,CMC1,CMC2,prcp_in,ETATOT,dsmctot_av



!---------------------------------------------------------------------
! NEW VARIABLES ADDED DURING NOAH F90 UPGRADE CALL to SFLX
!---------------------------------------------------------------------


! INTENT(IN) to SFLX:
  INTEGER, PARAMETER :: ICE = 0     ! Sea-ice flag  (=1: sea-ice, =0: land)
  REAL    :: DT       ! Timestep (s) (DT should not exceed 3600 S, recommend 1800 s or less)
  REAL    :: ZLVL     ! Height (m) above ground of atmospheric forcing variables
  INTEGER :: NSOIL    ! Number of soil layers
  REAL, ALLOCATABLE, DIMENSION(:) :: SLDPTH ! The THICKNESS (m) of each soil layer 
  CHARACTER(LEN=4) :: LLANDUSE ! (=USGS, using USGS landuse classification)
  CHARACTER(LEN=4) :: LSOIL    ! (=STAS, using FAO/STATSGO soil texture classification)

  REAL :: LWDN      ! LW downward radiation (W m-2; positive, not net longwave)
  REAL :: SOLDN     ! Solar downward radiation (W m-2; positive, not net solar)
  REAL :: SFCPRS    ! Pressure (Pa) at height ZLVL m above ground
  REAL :: PRCP      ! Precip rate (kg m-2 s-1) (NOTE: this is a rate)
  REAL :: SFCTMP    ! Air temperature (K) at height ZLVL m above ground
  REAL :: Q2        ! Mixing ratio (kg kg-1) at height ZLVL m above ground 
  REAL :: SFCSPD    ! Wind speed (m s-1) at height ZLVL m above ground
  REAL :: PRCPRAIN  ! Liquid-precipitation rate (KG M-2 S-1) (not used)
  REAL :: TH2       ! Air potential temperature (K) at height ZLVL m above ground
  REAL :: Q2SAT     ! Sat mixing ratio (kg kg-1) at height ZLVL m above ground
  REAL :: DQSDT2    ! Slope of sat specific humidity curve  (kg kg-1 K-1) at T=SFCTMP
  INTEGER :: VEGTYPX! Vegetation type (integer index)
  INTEGER :: SOILTYP! Soil type (integer index)
  INTEGER ::SLOPETYP! Class of sfc slope (integer index)
  REAL :: SHDMIN    ! Minimum areal fractional coverage of green vegetation
  !         (dimensionless fraction 0.0-1.0) <= SHDFAC
  REAL :: SHDMAX    !UNDOCUMENTED IN SFLX
  REAL :: TBOT      ! Bottom soil temperature (local yearly-mean of surfacc air temperature)


  REAL WATHOLDCAP

! INTENT(INOUT) to/from SFLX:
  REAL :: SNCOVR  ! Fractional snow cover (dimensionless fraction, 0.0-1.0)
  REAL :: COSZ    ! Solar zenith angle (not used for now)
  REAL :: SOLARDIRECT ! Direct component of downward solar radiation (W m-2) (not used)
  REAL :: Z0      ! Time varying roughness length (m) as function of snow depth
  REAL :: CMCX    ! Canopy moisture content (m)
  REAL :: T1X     ! Ground/Canopy/Snowpack effective skin temperature (K)
  REAL, allocatable, DIMENSION(:)  :: STC1    ! Soil temp (K)                            
  REAL, allocatable, DIMENSION(:)  :: SMC1    ! Total soil moisture content (volumetric fraction)
  REAL, allocatable, DIMENSION(:)  :: SH2O    ! Unfrozen soil moisture content (volumetric fraction)
  !          NOTE: Frozen soil moisture = SMC - SH2O
  REAL :: SNOWH   ! Actual snow depth (m)                                      
  REAL :: SNEQV   ! Liquid water-equivalent snow depth (m)                     
  !       NOTE: snow density = SNEQV/SNOWH                         
  REAL :: ALBEDO  ! Surface albedo including snow effect (unitless fraction)   
  !      =snow-free albedo (ALB) when SNEQV=0, or                 
  !      =FCT(MSNOALB,ALB,VEGTYP,SHDFAC,SHDMIN) when SNEQV>0      
  REAL :: CH      ! Surface exchange coefficient for heat and moisture         
  !   (m s-1); NOTE: CH is technically a conductance since     
  !   it has been multiplied by wind speed.                    
  REAL :: CM      ! Surface exchange coefficient for momentum (m s-1); NOTE:   
  !   CM is technically a conductance since it has been        
  !   multiplied by wind speed.                                

! INTENT(OUT) from SFLX:
  REAL :: ETT     ! Total plant transpiration (W m-2)
  REAL :: ETA     ! Actual latent heat flux (W m-2: negative, if up from surface)     
!KWM ???  Is the note about the sign of ETA right ???? !KWM
  REAL :: SHEAT   ! Sensible heat flux (W m-2: negative, if upward from surface)
  REAL :: ETA_KINEMATIC ! Actual latent heat flux (kg m/s)
  REAL :: FDOWN   ! Radiation forcing at the surface (W m-2) = SOLDN*(1-alb)+LWDN
  REAL :: EC      ! Canopy water evaporation (W m-2)
  REAL :: EDIR    ! Direct soil evaporation (W m-2)
  REAL, allocatable, DIMENSION(:) :: ET      ! Plant transpiration from a particular root (soil) layer (W m-2)
  REAL :: ESNOW   ! Sublimation from (or deposition to if <0) snowpack (W m-2)
  REAL :: DRIP    ! Through-fall of precip and/or dew in excess of canopy
  ! water-holding capacity (m)
  REAL :: DEW     ! Dewfall (or Frostfall for T<273.15) (m)

  REAL :: BETA    ! Ratio of actual to potential evap (dimensionless)
  REAL :: ETP     ! Potential Evaporation (w m-2)
  REAL :: SSOIL   ! Soil heat flux (W m-2: negative if downward from surface)
  REAL :: FLX1    ! Precip-snow sfc (W m-2)
  REAL :: FLX2    ! Freezing rain latent heat flux (W m-2)      
  REAL :: FLX3    ! Phase-change heat flux from snowmelt (W m-2)
  REAL :: SNOMLT  ! Snow melt (m) (water equivalent)
  REAL :: RUNOFF1 ! Surface runoff (m s-1), not infiltrating the surface
  REAL :: RUNOFF2 ! Subsurface runoff (m s-1), drainage out bottom of last
  !       soil layer (baseflow).  Note: RUNOFF2 is actually 
  !       the sum of RUNOFF2 and RUNOFF3
  REAL :: RUNOFF3 ! Numerical trunctation in excess of porosity (SMCMAX)
  ! for a given soil layer at the end of a time step (m s-1).
  REAL :: RC      ! Canopy resistance (s m-1)
  REAL :: PC      ! Plant coefficient (dimensionless fraction, 0.0-1.0) 
  ! where PC*ETP = actual transpiration
  REAL :: RCS     ! Incoming solar RC factor (dimensionless)
  REAL :: RCT     ! Air temperature RC factor (dimensionless)
  REAL :: RCQ     ! Atmos. vapor pressure deficit RC factor (dimensionless)
  REAL :: RCSOIL  ! Soil moisture RC factor (dimensionless)
  REAL :: SOILW   ! Available soil moisture in root zone (dimensionless fraction
  !      between SMCWLT and SMCMAX)
  REAL :: SOILM   ! Total soil column moisture content (frozen+unfrozen) (m)
  REAL :: Q1      ! Effective mixing ratio at surface (kg kg-1), used for
  !      diagnosing the mixing ratio at 2 meter for 
  !      coupled model

  real ::  snoalb, frzx
  logical :: local = .TRUE.
  integer :: kyw
  character*80, file1_yw
  character*80, file2_yw


!---------------------------------------------------------------------
!  DECLARE/Initialize constants
!---------------------------------------------------------------------

  REAL, PARAMETER :: R=287.04
  REAL, PARAMETER :: CPHEAT=1004.5
  INTEGER, PARAMETER :: LAND=1

  character(len=19) :: olddate, newdate, startdate
  CHARACTER(len=256) :: inflnm, outflnm,ywinflnm
  CHARACTER(len=256) :: inflnm2="init_channel_state.dat"
  character :: hgrid

! NAMELIST:

  CHARACTER(len=256) :: indir
  integer :: igrid
  character(len=256) :: range = ""
  character(len=256) :: wrfsi_static_flnm = ""
  character(len=256) :: wrfsi_finegrid_flnm = ""
  character(len=19)  :: restart_hdate = ""
  character(len=256) :: route_topo_f=""
  character(len=256) :: route_chan_f=""
  character(len=256) :: route_link_f=""
  character(len=256) :: route_lake_f=""
  character(len=256) :: route_direction_f=""
  character(len=256) :: route_order_f=""
  character(len=256) :: gwbasmskfil =""
  character(len=256) :: gwstrmfil =""

  integer            :: split_output_count
  logical            :: history_output
  

!DJG Modified namelist for routing and agg. variables

  integer :: START_YEAR, START_MONTH, START_DAY, START_HOUR, START_MIN
  integer :: rt_option      ! 1 for 1 direction routing.
                            ! 2 for 2 direction routing.
  integer :: channel_option = 3  ! 1 for Muskingum, 2 kinematic, 3 diffusive wave

  real Z_tmp

  integer, parameter :: iunit = 10
  integer, parameter :: ounit = 11
  integer :: g_ixrt,g_jxrt,flag

  integer iywtmp

  real ZSOIL8(8)


  namelist /NOAHLSM_OFFLINE/ INDIR, FORC_TYP, NSOIL, ZSOIL8, DT, TBOT, &
    START_YEAR, START_MONTH, START_DAY, START_HOUR, START_MIN, DOY, &
    RESTART_HDATE,RSTRT_SWC,HISTORY_OUTPUT,SPLIT_OUTPUT_COUNT,IGRID,RANGE, &
    KHOUR, KDAY, ZLVL, Z, wrfsi_static_flnm, wrfsi_finegrid_flnm, &
    AGGFACTRT, SUBRTSWCRT, &
    OVRTSWCRT,GWBASESWCRT,CHANRTSWCRT,DTRT,DXRT,SLOPETYP, SNOW_ASSIM, &
    TERADJ_SOLAR,HIRES_OUT, route_lake_f, route_topo_f,route_chan_f, &
    route_link_f, route_direction_f, route_order_f, rt_option, &
    gwbasmskfil, gwstrmfil, channel_option, DEEPGWSPIN


contains 

  subroutine rtland_init(ntime)
  implicit none
  INTEGER   :: NTIME, ix_tmp, jx_tmp

!wwwww  call WRF_LAND_INIT(1,2,3,4)  

  nsoil = -999
  zsoil = -999.
  dt = -999.
  tbot = -999.
  start_year = -999
  start_month = -999
  start_day = -999
  start_hour = -999
  start_min = -999
  khour = -999
  kday = -999
  zlvl = -999.
  z = -999.
  chan_out = 0.
  history_output = .FALSE.

#ifdef MPP_LAND

#ifdef COUPLED 
    call getMy_global_id() 
#else
    ! initilization for stand alone parallel code. 
    call  MPP_LAND_INIT(1)
#endif
#endif

#ifdef MPP_LAND
  if(my_id .eq. 0) then
#endif
    open(30, file="noah_wrfcode.namelist", form="FORMATTED")
    read(30, NOAHLSM_OFFLINE, iostat=ierr)
    close(30)
    ZSOIL(1:8) = ZSOIL8(1:8)
#ifdef MPP_LAND
  endif
#endif

#ifdef MPP_LAND
  !bcast namelist variable.
  call mpp_land_bcast_int1(rstrt_swc)
  call mpp_land_bcast_int1(AGGFACTRT)
  call mpp_land_bcast_int1(NSOIL)
  call mpp_land_bcast_int1(FORC_TYP)
  call mpp_land_bcast_real(NSOIL,ZSOIL)
  call mpp_land_bcast_real1(DT)
  call mpp_land_bcast_real1(TBOT)
  call mpp_land_bcast_int1(START_YEAR)
  call mpp_land_bcast_int1(START_MONTH)
  call mpp_land_bcast_int1(START_DAY)
  call mpp_land_bcast_int1(START_HOUR)
  call mpp_land_bcast_int1(START_MIN)
  call mpp_land_bcast_int1(SPLIT_OUTPUT_COUNT)
  call mpp_land_bcast_int1(IGRID)
  call mpp_land_bcast_int1(KHOUR)
  call mpp_land_bcast_int1(KDAY)
  call mpp_land_bcast_real1(ZLVL)
  call mpp_land_bcast_int1(SUBRTSWCRT)
  call mpp_land_bcast_int1(OVRTSWCRT)
  call mpp_land_bcast_int1(GWBASESWCRT)
  call mpp_land_bcast_int1(CHANRTSWCRT)
  call mpp_land_bcast_int1(HIRES_OUT)
  call mpp_land_bcast_real1(DTRT)
  call mpp_land_bcast_real1(DXRT)
  call mpp_land_bcast_int1(SLOPETYP)
  call mpp_land_bcast_int1(SNOW_ASSIM)
  call mpp_land_bcast_int1(rt_option)
  call mpp_land_bcast_int1(channel_option)
  call mpp_land_bcast_real1(Z)
  call mpp_land_bcast_int1(TERADJ_SOLAR)
  call mpp_land_bcast_int1(DEEPGWSPIN)
#endif

  write(6,*) "rt_option is :",rt_option
  write(6,*) "channel_option = ",channel_option
  call flush(6)
!yw  if(rt_option .eq. 0) call land_finish()


#ifdef COUPLED
  numprocs = node_info(1,1)
  call wrf_LAND_set_INIT(node_info,numprocs,AGGFACTRT)
#endif

!---------------------------------------------------------------------
! END Declarations 
!---------------------------------------------------------------------

 !DJG,DNY Error check for chan routing w/out terrain routing...
     print *, "FORC_TYP =", FORC_TYP
     IF(CHANRTSWCRT.eq.1) THEN
       IF(OVRTSWCRT.eq.0.AND.SUBRTSWCRT.eq.0) THEN
         print *, "Program aborted!!!"
         print *, "Can not run channel routing without terrain routing!!!"
         print *, "Please correct namelist file switches."
         call land_finish()
       END IF
     END IF

  LLANDUSE = 'USGS'
  LSOIL = 'STAS'

  ! Initialize namelist variables to dummy values, so we can tell
  ! if they have not been set properly.



  if ((khour < 0) .and. (kday < 0)) then
     write(*, '("Namelist problem:  Either KHOUR or KDAY must be defined.")')
     call land_finish()
  else if (( khour < 0 ) .and. (kday > 0)) then
     khour = kday * 24
  else if ((khour > 0) .and. (kday > 0)) then
#ifdef MPP_LAND
      if(my_id .eq. IO_id ) then
#endif
         write(*, '("Namelist warning:  KHOUR and KDAY both defined.")')
#ifdef MPP_LAND
      endif
#endif
  else
     ! all is well.  KHOUR defined
  endif

#ifdef MPP_LAND
      if(my_id .eq. IO_id ) then
#endif
  write(olddate,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,":",I2.2,":",I2.2)') &
       start_year, start_month, start_day, start_hour, start_min, 0

  startdate = olddate
  write(hgrid,'(I1)') igrid

  !!DJG Setup forcing data filenames here...
!!!
  if (FORC_TYP.ne.3) then     ! Forctype not COWS...
    if (len_trim(range) == 0) then
       inflnm = trim(indir)//"/"//&
          startdate(1:4)//startdate(6:7)//startdate(9:10)//startdate(12:13)//&
          ".LDASIN_DOMAIN"//hgrid
    else
       inflnm = trim(indir)//"/"//&
            startdate(1:4)//startdate(6:7)//startdate(9:10)//startdate(12:13)//&
            ".LDASIN_DOMAIN"//hgrid//"."//trim(range)
    endif
  else     !for COWS only...
    ix=60  !COWS
    jx=40  !COWS
    if (len_trim(range) == 0) then
      inflnm = trim(indir)//"/"//&
        "MET_LIS_CRO_2D_SANTEE_LU_1KM."//&
        startdate(1:4)//DOY//startdate(12:13)//&
        ".156hrfcst.radar"
    else
    endif
  endif


  if (FORC_TYP.ne.3)  then    !normal read of wrfstatic data...
#ifdef MPP_LAND
  call read_hrldas_hdrinfo(wrfsi_static_flnm, ix_tmp, jx_tmp, land_cat, soil_cat)
#else
  call read_hrldas_hdrinfo(wrfsi_static_flnm, ix, jx, land_cat, soil_cat)
#endif
  else   !COWS
  endif


#ifdef MPP_LAND
#ifndef COUPLED
    global_nx = ix_tmp
    global_ny = jx_tmp
    g_IXRT=global_nx*AGGFACTRT 
    g_JXRT=global_ny*AGGFACTRT 
#endif 
#endif

#ifdef MPP_LAND
  endif   ! end of IO if

  call mpp_land_bcast_int1(g_ixrt)
  call mpp_land_bcast_int1(g_jxrt)
  write(6,*) "yyww debug g_ixrt, g_jxrt:", g_ixrt,g_jxrt
  call flush(6) 
#endif

!define global variable and allocate the global array for IO_id node.
!following global variable moved back for debuggin purpose.



#ifdef MPP_LAND

#ifdef COUPLED
    ix = local_nx
    jx = local_ny 
    g_IXRT = global_rt_nx 
    g_JXRT = global_rt_ny
    ixrt = local_rt_nx
    jxrt = local_rt_ny
#endif
  call mpp_land_bcast_int1(global_nx)
  call mpp_land_bcast_int1(global_ny)


! replace the (IX,JX) with local ix,jx
#ifndef COUPLED
  ix = global_nx
  jx = global_ny
  call MPP_LAND_PAR_INI(1,ix,jx,AGGFACTRT)
#endif
#endif

!DJG  SETTING DISAGGREGATION GRID SIZE
#ifdef MPP_LAND
    ixrt = local_rt_nx
    jxrt = local_rt_ny
#else
    IXRT=ix*AGGFACTRT
    JXRT=jx*AGGFACTRT
#endif

  if (nsoil < 0) then
     write(6,*) " ***** ERROR: NSOIL must be set in the namelist."
     call land_finish()
  endif

#ifdef MPP_LAND
    if(my_id.eq.IO_id) then
#endif

  write(olddate,'(I4.4,"-",I2.2,"-",I2.2,"_",I2.2,":",I2.2,":",I2.2)') &
       start_year, start_month, start_day, start_hour, start_min, 0

  startdate = olddate
  olddate = startdate(1:16)

!......................... end of model configuration (later in a namelist) .....

#ifdef MPP_LAND
    endif
#endif

  CALL LSM_PARM_INIT          !yyww need to change later

  write(6,*) "Finish call LSM_PARM_INIT"
  call flush(6)

!----------------------------------------------------------------------
! Allocate arrays for our gridded domain, now that we know the size
!----------------------------------------------------------------------
  allocate( VEGTYP   (IX,JX) )
  allocate( SOLTYP   (IX,JX) )
  allocate( TERRAIN  (IX,JX) )
  allocate( LATITUDE (IX,JX) )
  allocate( LONGITUDE(IX,JX) )
  allocate( T2       (IX,JX) )
  allocate( XLONG    (IX,JX) )
  allocate( U        (IX,JX) )
  allocate( V        (IX,JX) )
  allocate( PRES     (IX,JX) )
  allocate( SHORT    (IX,JX) )
  allocate( PRCP1    (IX,JX) )
  allocate( PRCP_OUT (IX,JX) )
  allocate( FPAR     (IX,JX) )
  allocate( LAI      (IX,JX) )
!DJG_DES Allocate arrays GREENFRAC and ALBEDO12M
  allocate( GREENFRAC(IX,JX) )
  allocate( ALBEDO12M(IX,JX) )
  allocate( CMC      (IX,JX) )
  allocate( SNODEP   (IX,JX) )
  allocate( WEASD    (IX,JX) )
  allocate( ZNT      (IX,JX) )
  allocate( SNOWC    (IX,JX) )
  allocate( T1       (IX,JX) )
  allocate( ETPX     (IX,JX) )
  allocate( ETAX     (IX,JX) )
  allocate( ETAKIN   (IX,JX) )
  allocate( SOILHX   (IX,JX) )
  allocate( LH_yw   (IX,JX) )
  allocate( SOILW_yw   (IX,JX) )
  allocate( SOILM_yw   (IX,JX) )
  allocate( CHX      (IX,JX) )
  allocate( RUNOFF1X (IX,JX) )
  allocate( RUNOFF2X (IX,JX) )
  allocate( RUNOFF3X (IX,JX) )
  allocate( EDIRX    (IX,JX) )
  allocate( ECX      (IX,JX) )
  allocate( ETTX     (IX,JX) )
  allocate( SNMAXX   (IX,JX) )
  allocate( RCX      (IX,JX) )
  allocate( HX       (IX,JX) )
  allocate( QFX      (IX,JX) )
  allocate( QSFC     (IX,JX) )
  allocate( Q2X      (IX,JX) )
  allocate( SFCSPDX  (IX,JX) )
  allocate( ALBEDX   (IX,JX) )
  allocate( SMCMAX1  (IX,JX) )
  allocate( SMCWLT1  (IX,JX) )
  allocate( SMCREF1  (IX,JX) )
  allocate( ACSNOM   (IX,JX) )
  allocate( ACRAIN   (IX,JX) )
  allocate( ACRAIN_0   (IX,JX) )
  allocate( ESNOW2D  (IX,JX) )
!KWM  allocate( SNOFLXX  (IX,JX) )
  allocate( SNOEVPX  (IX,JX) )
  allocate( FX       (IX,JX) )
  allocate( RESX     (IX,JX) )
  allocate( DRIP2D   (IX,JX) )
  allocate( DEWFALL  (IX,JX) )
  allocate( SOILMX   (IX,JX) )
  allocate( EMISS    (IX,JX) )
!DJG  allocate   few vars on native grird
  allocate( LKSAT    (IX,JX) )
  allocate( ETPNDX   (IX,JX) )
  allocate( SFCHEADRT  (IX,JX) )
  allocate( INFXSRT   (IX,JX) )
  allocate( SOLDRAIN (IX,JX) )
  allocate( BASIN_MSK   (IX,JX) )
  allocate( LAK_1K   (IX,JX) )
!KWM  allocate( PDDUM2   (IX,JX) )
!KWM  allocate( PCPDRP   (IX,JX) )
!KWM  allocate( SFCWATR2 (IX,JX) )

  allocate( SMC  (IX,JX,NSOIL) ) 
  allocate( SICE  (IX,JX,NSOIL) ) 
  allocate( STC  (IX,JX,NSOIL) )
  allocate( SH2OX(IX,JX,NSOIL) )
  allocate( ZSOILX(IX,JX,NSOIL) )
  allocate( ZLVL_WRF(IX,JX) )
  allocate( TBOT_WRF(IX,JX) )
  allocate( z0_WRF(IX,JX) )

  allocate( SH2O   (NSOIL) )
  allocate( SLDPTH (NSOIL) )
  allocate( SMC1   (NSOIL) )
  allocate( STC1   (NSOIL) )
  allocate( ET     (NSOIL) )

!DJG Allocate routing and disaggregation arrays

  allocate( SMCRT   	(IXRT,JXRT,NSOIL) )
  allocate( ELRT   	(IXRT,JXRT) )
  allocate( SOXRT  	(IXRT,JXRT) )
  allocate( SOYRT   	(IXRT,JXRT) )
  allocate( SO8RT   	(IXRT,JXRT,8) )
  allocate( SO8RT_D   	(IXRT,JXRT,3) )
  allocate( SO8LD_D   	(IX,JX,3) )

  allocate(SO8LD_Vmax(IX,JX) )
  allocate( OVROUGHRT   (IXRT,JXRT) )
  allocate( RETDEPRT    (IXRT,JXRT) )
  allocate( SFCHEADSUBRT(IXRT,JXRT) )
  allocate( INFXSUBRT   (IXRT,JXRT) )
  allocate( INFXSWGT    (IXRT,JXRT) )
  allocate( LKSATRT     (IXRT,JXRT) )
  allocate( LKSATFAC    (IXRT,JXRT) )
  allocate( QSUBRT      (IXRT,JXRT) )
  allocate( ZWATTABLRT  (IXRT,JXRT) )
  allocate( QSUBBDRYRT  (IXRT,JXRT) )
  allocate( SOLDEPRT    (IXRT,JXRT) )
  allocate( q_sfcflx_x  (IXRT,JXRT) )
  allocate( q_sfcflx_y  (IXRT,JXRT) )
  allocate( SMCMAXRT   	(IXRT,JXRT,NSOIL) )
  allocate( SMCWLTRT   	(IXRT,JXRT,NSOIL) )
  allocate( SH2OWGT   	(IXRT,JXRT,NSOIL) )
  allocate( INFXSAGGRT 	(IXRT,JXRT) )
  allocate( DHRT   	(IXRT,JXRT) )
  allocate( QSTRMVOLRT  (IXRT,JXRT) )
  allocate( QSTRMVOLRT_TS  (IXRT,JXRT) )
  allocate( QSTRMVOLRT_DUM  (IXRT,JXRT) )
  allocate( ywtmp       (IXRT,JXRT) )
  allocate( QBDRYRT   	(IXRT,JXRT) )
  allocate( CH_NETRT   	(IXRT,JXRT) )
  allocate( LAKE_MSKRT 	(IXRT,JXRT) )
  allocate( LAKE_INFLORT(IXRT,JXRT) )
  allocate( LAKE_INFLORT_TS(IXRT,JXRT) )
  allocate( LAKE_INFLORT_DUM(IXRT,JXRT) )
  allocate( SMCAGGRT   	(NSOIL) )
  allocate( STCAGGRT   	(NSOIL) )
  allocate( SH2OAGGRT  	(NSOIL) )

  allocate( SUB_RESID (ixrt,jxrt) )
  allocate( LATVAL (ixrt,jxrt) )
  allocate( LONVAL (ixrt,jxrt) )



! allocate channel routing and lake routing arrays
  allocate( CH_NETLNK (IXRT,JXRT) )

!DJG,DNY Allocate channel routing and lake routing arrays

  IF (CHANRTSWCRT.EQ.1 .or. CHANRTSWCRT .eq. 2) THEN  !IF/then for channel routing
#ifdef MPP_LAND
    CALL MPP_READ_ROUTEDIM(IXRT,JXRT,route_chan_f,route_link_f, &
             route_direction_f,route_lake_f,NLINKS, NLAKES, &
             CH_NETLNK,channel_option,wrfsi_finegrid_flnm,g_IXRT,g_JXRT)

#else
      CALL READ_ROUTEDIM(IXRT, JXRT, route_chan_f, route_link_f, &
              route_direction_f, route_lake_f, NLINKS, NLAKES, &
              CH_NETLNK, channel_option, wrfsi_finegrid_flnm)
#endif

      print *, "nlinks found", NLINKS
      print *, "nlakes found", NLAKES 
!--- now allocate the memory according to the number of links and nodes
!     allocate( CHANN(NLINKS) )

#ifdef MPP_LAND
     allocate( LAKE_INDEX(NLINKS) )
     allocate( nlinks_INDEX(NLINKS) )
     allocate( Link_location(ixrt,jxrt))
#endif
     
     allocate( LINK(NLINKS) )
     allocate( TO_NODE(NLINKS) )
     allocate( FROM_NODE(NLINKS) )
     allocate( TYPEL(NLINKS) )
     allocate( ORDER(NLINKS) )
     allocate( STRMFRXSTPTS(NLINKS) )
     allocate( MUSK(NLINKS) )
     allocate( MUSX(NLINKS) )
     allocate( CHANXI(NLINKS) )
     allocate( CHANYJ(NLINKS) )
     allocate( CHLAT(NLINKS) )   !-latitutde of channel grid point
     allocate( CHLON(NLINKS) )   !-longitude of channel grid point
     allocate( CHANLEN(NLINKS) )
     allocate( So(NLINKS) )
     allocate( ChSSlp(NLINKS) )
     allocate( Bw(NLINKS) )
     allocate( ZELEV(NLINKS) )
     allocate( CVOL(NLINKS) )
   
     allocate( HRZAREA(NLINKS) )
     allocate( LAKEMAXH(NLINKS) )
     allocate( WEIRC(NLINKS) )
     allocate( WEIRL(NLINKS) )
     allocate( ORIFICEC(NLINKS) )
     allocate( ORIFICEA(NLINKS) )
     allocate( ORIFICEE(NLINKS) )
     allocate( LATLAKE(NLINKS) )
     allocate( LONLAKE(NLINKS) )
     allocate( ELEVLAKE(NLINKS) )

     allocate( LAKENODE(NLINKS) )
     allocate( RESHT(NLINKS),STAT=istatus )
     allocate( QLAKEI(NLINKS),STAT=istatus )
     allocate( QLAKEO(NLINKS),STAT=istatus )
     allocate( QLINK(NLINKS,2) )

     allocate( HLINK(NLINKS) )  !--used for diffusion only
     allocate( MannN(NLINKS))

     LAKEMAXH = 0.    
     LATLAKE = 0.
     LONLAKE = 0.
     LAKENODE = 0
     QLAKEO = 0.
     QLINK = 0
     MannN =0. 
     ChSSlp = 0.
     Bw = 0.
     QLAKEI = 0.0
     RESHT  = 0.
     WEIRL  = 0.
     ORIFICEE = 0.
     ZELEV = 0.
     HLINK = 0.
     So = 0.01
     TYPEL = 0
  END IF   !IF/then for channel routing


  !DJG Allocate routing and disaggregation arrays
  allocate(GWSUBBASMSK  (IX,JX) )
  allocate(qinflowbase  (IXRT,JXRT) )
  allocate(gw_strm_msk  (IXRT,JXRT) )

! allocate channel routing and lake routing arrays
!yw    allocate( CH_NETLNK (IXRT,JXRT) )

!DJG Allocate mass balance calc arrays
 
  allocate( DSMC        (NSOIL) )
  allocate( SMCRTCHK    (NSOIL) )
  allocate( CMC_INIT    (IX,JX) )
  allocate( SWE_INIT    (IX,JX) )
!  allocate( SMC_INIT    (IX,JX,NSOIL) )

  print *, "done allocating"

!----------------------------------------------------------------------
! Initialize gridded domain
!----------------------------------------------------------------------


  ! SLDPTH is the thickness of each layer
  SLDPTH(1) = -ZSOIL(1)
  do i = 2, nsoil
     sldpth(i) = zsoil(i-1)-zsoil(i)
  enddo

  ETAX=0.0 ! -999.9
  ETAKIN=0.0 ! -999.9
  ETPX=0.0 ! -999.9
  CHX=-999.9
  FX=-999.9
  HX=-999.9
  RESX=-999.9
  SOILHX=-999.9
  CMC=0.0
  T2=-999.9
  T1=-999.9
  PRCP1=-999.9
  PRCP_OUT=0.0

  RUNOFF1X=0.0 
  RUNOFF2X=0.0 
  RUNOFF3X=0.0 
  EDIRX=0.0
  ETTX=0.0
  SNOEVPX=-999.9
  SNODEP=-999.9

  STC=-999.9
  SH2OX=-999.9
  SMC=-999.9
  SICE=-999.9

  ECX=0.0
  ACSNOM  = 0.0
  ACRAIN  = 0.0
  ACRAIN_0  = 0.0
  ESNOW2D = 0.0
  DRIP2D = 0.0
  DEWFALL = 0.0
  SOILMX = -999.

!DJG Initialize routing and aggregation fields
  ETPNDX=0.0
  SOLDEPRT = -1.0*ZSOIL(NSOIL)
  QSUBRT = 0.0
  ZWATTABLRT = 0.0
  QSUBBDRYRT = 0.0
  QSTRMVOLRT = 0.0
  QSTRMVOLRT = 0.0
  QSTRMVOLRT_TS = 0.0
  QBDRYRT = 0.0
  SFCHEADRT = 0.0
  SFCHEADSUBRT = 0.0
  INFXSRT = 0.0
  INFXSUBRT = 0.0
  DHRT = 0.0
  LAKE_MSKRT = 0
  LAKE_INFLORT = 0.0
  LAKE_INFLORT_TS = 0.0
  LAKE_INFLORT_DUM = 0.0
  LAKE_CT = 0
  STRM_CT = 0
  QSTRMVOLRT_DUM = 0.0
  SOLDRAIN = 0.0
  qinflowbase = 0.0

  BASIN_MSK = 1

!DJG Initialize mass balance check variables...
  SMC_INIT=0.
  DSMC=0.
  DACRAIN=0.
  DSFCEVP=0.
  DCANEVP=0.
  DEDIR=0.
  DETT=0.
  DEPND=0.
  DESNO=0.
  DSFCRNFF=0.
  DQBDRY=0.
  SUMINFXS1=0.


!---------------------------------------------------------------------
! Initialize static surface data
!---------------------------------------------------------------------


!   OK     VEGTYP     VEGETATION TYPE (INTEGER INDEX)
!   OK     SOILTYP    SOIL TYPE (INTEGER INDEX)
!   OK     SLOPETYP   CLASS OF SFC SLOPE (INTEGER INDEX)
!          SHDMIN     MINIMUM AREAL FRACTIONAL COVERAGE OF GREEN VEGETATION
!                (FRACTION= 0.0-1.0) <= SHDFAC
!   N/U    PTU        PHOTO THERMAL UNIT (PLANT PHENOLOGY FOR ANNUALS/CROPS)
!                (NOT YET USED, BUT PASSED TO REDPRM FOR FUTURE USE IN
!                VEG PARMS)
!   OK     ALB        BACKROUND SNOW-FREE SURFACE ALBEDO (FRACTION), FOR JULIAN
!                DAY OF YEAR (USUALLY FROM TEMPORAL INTERPOLATION OF
!                MONTHLY MEAN VALUES' CALLING PROG MAY OR MAY NOT
!                INCLUDE DIURNAL SUN ANGLE EFFECT)
!   OK     SNOALB     UPPER BOUND ON MAXIMUM ALBEDO OVER DEEP SNOW (E.G. FROM
!                ROBINSON AND KUKLA, 1985, J. CLIM. & APPL. METEOR.)
!   OK     TBOT       BOTTOM SOIL TEMPERATURE (LOCAL YEARLY-MEAN SFC AIR
!                TEMPERATURE)
!   ??     Z0BRD      Background fixed roughness length (M)
!   ??     Z0         Time varying roughness length (M) as function of snow depth




!----------------------------------------------------------------------
! Read Landuse Type and Soil Texture and Other Information
!----------------------------------------------------------------------

!KWM         CALL READLAND(IX,JX,VEGTYP,SOLTYP, TERRAIN, LATITUDE,LONGITUDE)
!KWM  CALL READLAND_IHOP(DIR,IX,JX,VEGTYP,SOLTYP,TERRAIN,LATITUDE,LONGITUDE)
!KWM  CALL READLAND_RTFDDA(IUNIT,IX,JX,VEGTYP,SOLTYP,TERRAIN,LATITUDE,LONGITUDE)
!DJG  CALL READLAND_HRLDAS(wrfsi_static_flnm,IX,JX,LAND_CAT,SOIL_CAT,      &
!DJG       VEGTYP,SOLTYP,TERRAIN,LATITUDE,LONGITUDE)



#ifdef MPP_LAND
     CALL MPP_READLAND_HRLDAS(trim(wrfsi_static_flnm),ix,&
          jx,LAND_CAT,SOIL_CAT,      &
          VEGTYP,SOLTYP,TERRAIN,LATITUDE,LONGITUDE, &
          global_nx, global_ny)
#else
  CALL READLAND_HRLDAS(wrfsi_static_flnm,IX,JX,LAND_CAT,SOIL_CAT,      &
      VEGTYP,SOLTYP,TERRAIN,LATITUDE,LONGITUDE)
#endif


!== quick fix for COWPENS so no bound error ======== july 08
 do j = 1, jx
    do i = 1, ix
          if(vegtyp(i,j) .eq. 0) vegtyp(i,j) = 7
    end do
 end do


!!!!DJG Modify terrain fields for DMIP_II domains...
!yw        IF (FORC_TYP.eq.8) then
        IF (FORC_TYP.eq.118) then

#ifdef MPP_LAND
       print*, "Error: parallel code not finished for this part."
       call land_finish()
#endif
         dat_dir="/d2/hydrolab/HRLDAS/terrain/DMIP_II_AmerR/"
!Read in DMIP vegetation type...
         open (77,file=trim(dat_dir)//"am_veg.txt",&
                form="formatted",status="old")
!Read in DMIP soil type ...
         open (78,file=trim(dat_dir)//"am_sol.txt",&
                form="formatted",status="old")
!Read in DMIP basin mask ...
#ifdef MPP_LAND
    print*, "Error:  parallelization not done !!"
    call land_finish()
#endif
         open (79,file=trim(dat_dir)//"am_1k_msk.txt",&
                form="formatted",status="old")
         do j=jx,1,-1
           read(77,*) (VEGTYP(I,J),I=1,ix)
           read(78,*) (SOLTYP(I,J),I=1,ix)
           read(79,*) (BASIN_MSK(I,J),I=1,ix)
!           print *, i,j
!Reset soil values outside basin to prevent crash...
!           if (VEGTYP(I,J).eq.16.) SOLTYP(I,J)=14
!           if (SOLTYP(I,J).le.0.) SOLTYP(I,J)=6
         end do
         ! Make sure vegtyp and soltyp are consistent when it comes to water
         ! points, by setting soil category to water
         ! when vegetation category is water and vice-versa.
         where (vegtyp == 16) soltyp = 14
         where (soltyp == 14) vegtyp = 16
!         where (soltyp == -9999) smcmax1 = 0.434
         smcmax1 = 0.434
         close(77)
         close(78)
         close(79)
        END IF
!!!!End modification of terrain fields for DMIP_II domains


!------------------------------------------------------------------------
!DJG Routing Processing
!------------------------------------------------------------------------
!DJG IF/then to get routing terrain fields if either routing module is 
!DJG   activated


  IF (SUBRTSWCRT.EQ.1.OR.OVRTSWCRT.EQ.1) THEN
  print *, "Terrain routing initialization..."
#ifdef MPP_LAND
    CALL MPP_READ_ROUTING(IXRT,JXRT,ELRT,CH_NETRT,LKSATFAC,trim(route_topo_f),&
          route_chan_f,wrfsi_finegrid_flnm,g_IXRT,g_JXRT)


#else
    CALL READ_ROUTING_old(IXRT,JXRT,ELRT,CH_NETRT,LKSATFAC,route_topo_f,route_chan_f, &
                         wrfsi_finegrid_flnm)
#endif


    IF (CHANRTSWCRT.EQ.1 .or. CHANRTSWCRT .eq. 2) THEN  !IF/then for channel routing
#ifdef MPP_LAND

          CALL MPP_READ_CHROUTING(IXRT,JXRT,ELRT,CH_NETRT, LAKE_MSKRT, &
               FROM_NODE, TO_NODE, TYPEL, ORDER, MAXORDER, NLINKS, &
               NLAKES, MUSK, MUSX, QLINK,CHANLEN, MannN, So, ChSSlp, Bw, &
               HRZAREA, LAKEMAXH, WEIRC, WEIRL, ORIFICEC, &
              ORIFICEA, ORIFICEE, LATLAKE, LONLAKE, ELEVLAKE, &
               route_link_f,route_lake_f, &
               route_direction_f, route_order_f, &
               CHANRTSWCRT,DXRT, ZELEV, LAKENODE, CH_NETLNK, CHANXI, CHANYJ, &
               CHLAT, CHLON, channel_option, FORC_TYP,latval,lonval,&
               STRMFRXSTPTS,wrfsi_finegrid_flnm, g_IXRT,g_JXRT)

          call MPP_CHROUTING_CONF(g_ixrt,g_jxrt,ixrt,jxrt, NLAKES,NLINKS,&
               lake_mskrt, lake_index,link_location,HRZAREA,LAKEMAXH,WEIRC,WEIRL,&
               ORIFICEC,ORIFICEA,ORIFICEE,LATLAKE,LONLAKE,ELEVLAKE, &
               FROM_NODE,TO_NODE,ZELEV,CHLAT,CHLON,TYPEL, ORDER,CHANLEN, &
               CHANXI,CHANYJ, lakenode,mpp_nlinks, nlinks_index, maxorder, &
               yw_mpp_nlinks)
!!!!!   lake_index,Link_Location)
#else
          CALL READ_CHROUTING(IXRT,JXRT,ELRT,CH_NETRT, LAKE_MSKRT, &
               FROM_NODE, TO_NODE, TYPEL, ORDER, MAXORDER, NLINKS, &
               NLAKES, MUSK, MUSX, QLINK,CHANLEN, MannN, So, ChSSlp, Bw, &
               HRZAREA, LAKEMAXH, WEIRC, WEIRL, ORIFICEC, &
               ORIFICEA, ORIFICEE, LATLAKE, LONLAKE, ELEVLAKE, &
               route_link_f,route_lake_f, &
               route_direction_f, route_order_f, &
               CHANRTSWCRT,DXRT, ZELEV, LAKENODE, CH_NETLNK, CHANXI, CHANYJ, &
               CHLAT, CHLON, channel_option, FORC_TYP,LATVAL,LONVAL, &
               STRMFRXSTPTS,wrfsi_finegrid_flnm)
#endif
    endif
  END IF

!   write(my_id+20,*) "step 1"
!DJG Temporary hardwire of RETDEPRT,RETDEP_CHAN
!DJG    will later make this a function of SOLTYP and VEGTYP
!            OVROUGHRT(i,j) = 0.01

              RETDEPRT = 0.05   ! units (mm)
              RETDEP_CHAN = 0.001


!DJG Need to insert call for acquiring routing fields here...
!DJG     include as a subroutine in module module_Noahlsm_wrfcode_input.F
!DJG  Calculate terrain slopes 'SOXRT,SOYRT' from subgrid elevation 'ELRT'

        Vmax = 0.0
        do j=2,JXRT-1
          do i=2,IXRT-1
              SOXRT(i,j)=(ELRT(i,j)-ELRT(i+1,j))/DXRT
              SOYRT(i,j)=(ELRT(i,j)-ELRT(i,j+1))/DXRT
!DJG Introduce reduction in retention depth as a linear function of terrain slope
              IF (RT_OPTION.eq.2) then
                IF (SOXRT(i,j).gt.SOYRT(i,j)) then
                  Vmax=SOXRT(i,j)
                ELSE
                  Vmax=SOYRT(i,j)
                END IF

                IF (Vmax.gt.0.1) then
                  RETDEPRT(i,j)=0.
                ELSE
                  RETDEPFRAC=Vmax/0.1
                  RETDEPRT(i,j)=RETDEPRT(i,j)*(1.-RETDEPFRAC)
                  IF (RETDEPRT(i,j).lt.0.) RETDEPRT(i,j)=0.
                END IF
              END IF

               SO8RT(i,j,1) = (ELRT(i,j)-ELRT(i,j+1))/DXRT
               SO8RT_D(i,j,1) = i
               SO8RT_D(i,j,2) = j + 1 
               SO8RT_D(i,j,3) = 1 
               Vmax = SO8RT(i,j,1)
               
               SO8RT(i,j,2) = (ELRT(i,j)-ELRT(i+1,j+1))/DXRT/sqrt(2.)
               if(SO8RT(i,j,2) .gt. Vmax ) then
                 SO8RT_D(i,j,1) = i + 1
                 SO8RT_D(i,j,2) = j + 1 
                 SO8RT_D(i,j,3) = 2
                 Vmax = SO8RT(i,j,2)
               end if

               SO8RT(i,j,3) = (ELRT(i,j)-ELRT(i+1,j))/DXRT
               if(SO8RT(i,j,3) .gt. Vmax ) then
                 SO8RT_D(i,j,1) = i + 1
                 SO8RT_D(i,j,2) = j  
                 SO8RT_D(i,j,3) = 3
                 Vmax = SO8RT(i,j,3)
               end if
               SO8RT(i,j,4) = (ELRT(i,j)-ELRT(i+1,j-1))/DXRT/sqrt(2.)
               if(SO8RT(i,j,4) .gt. Vmax ) then
                 SO8RT_D(i,j,1) = i + 1
                 SO8RT_D(i,j,2) = j - 1 
                 SO8RT_D(i,j,3) = 4
                 Vmax = SO8RT(i,j,4)
               end if
               SO8RT(i,j,5) = (ELRT(i,j)-ELRT(i,j-1))/DXRT
               if(SO8RT(i,j,5) .gt. Vmax ) then
                 SO8RT_D(i,j,1) = i 
                 SO8RT_D(i,j,2) = j - 1 
                 SO8RT_D(i,j,3) = 5
                 Vmax = SO8RT(i,j,5)
               end if
               SO8RT(i,j,6) = (ELRT(i,j)-ELRT(i-1,j-1))/DXRT/sqrt(2.)
               if(SO8RT(i,j,6) .gt. Vmax ) then
                 SO8RT_D(i,j,1) = i - 1 
                 SO8RT_D(i,j,2) = j - 1 
                 SO8RT_D(i,j,3) = 6
                 Vmax = SO8RT(i,j,6)
               end if
               SO8RT(i,j,7) = (ELRT(i,j)-ELRT(i-1,j))/DXRT
               if(SO8RT(i,j,7) .gt. Vmax ) then
                 SO8RT_D(i,j,1) = i - 1 
                 SO8RT_D(i,j,2) = j  
                 SO8RT_D(i,j,3) = 7
                 Vmax = SO8RT(i,j,7)
               end if
               SO8RT(i,j,8) = (ELRT(i,j)-ELRT(i-1,j+1))/DXRT/sqrt(2.)
               if(SO8RT(i,j,8) .gt. Vmax ) then
                 SO8RT_D(i,j,1) = i - 1 
                 SO8RT_D(i,j,2) = j + 1 
                 SO8RT_D(i,j,3) = 8
                 Vmax = SO8RT(i,j,8)
               end if

!DJG Introduce reduction in retention depth as a linear function of terrain slope
              IF (RT_OPTION.eq.1) then
                IF (Vmax.gt.0.1) then
                  RETDEPRT(i,j)=0.
                ELSE
                  RETDEPFRAC=Vmax/0.1
                  RETDEPRT(i,j)=RETDEPRT(i,j)*(1.-RETDEPFRAC)
                  IF (RETDEPRT(i,j).lt.0.) RETDEPRT(i,j)=0.
                END IF
              END IF

          end do
        end do

! calculate the slope for boundary        
#ifdef MPP_LAND
       if(right_id .lt. 0) SOXRT(IXRT,:)=SOXRT(IXRT-1,:)
       if(left_id  .lt. 0) SOXRT(1,:)=SOXRT(2,:)
       if(up_id    .lt. 0) SOYRT(:,JXRT)=SOYRT(:,JXRT-1)
       if(down_id  .lt. 0) SOYRT(:,1)=SOYRT(:,2)
#else
              SOXRT(IXRT,:)=SOXRT(IXRT-1,:)
              SOXRT(1,:)=SOXRT(2,:)
              SOYRT(:,JXRT)=SOYRT(:,JXRT-1)
              SOYRT(:,1)=SOYRT(:,2)
#endif

#ifdef MPP_LAND
! communicate the value to 
       call MPP_LAND_COM_REAL(RETDEPRT,IXRT,JXRT,99)
       call MPP_LAND_COM_REAL(SOXRT,IXRT,JXRT,99)
       call MPP_LAND_COM_REAL(SOYRT,IXRT,JXRT,99)
       do i = 1, 8
          call MPP_LAND_COM_REAL(SO8RT(:,:,i),IXRT,JXRT,99)
       end do
       do i = 1, 3
          call MPP_LAND_COM_INTEGER(SO8RT_D(:,:,i),IXRT,JXRT,99)
       end do
#endif
     IF (TERADJ_SOLAR.EQ.1 .and. CHANRTSWCRT.NE.2) THEN   ! Perform terrain adjustment of incoming solar
          DX = DXRT * AGGFACTRT
#ifdef MPP_LAND
          call MPP_seq_land_SO8(SO8LD_D,SO8LD_Vmax,TERRAIN,dx,ix,jx,global_nx,global_ny)
#else
          call seq_land_SO8(SO8LD_D,SO8LD_Vmax,TERRAIN,dx,ix,jx)
#endif
     endif

!---------------------------------------------------------------------
!DJG  If GW/Baseflow activated...Read in req'd fields...
!----------------------------------------------------------------------
  IF (GWBASESWCRT.GE.1) THEN


    If (GWBASESWCRT.EQ.1) THEN
      print *, "Simple GW-Bucket Scheme selected, retrieving files..."
#ifdef MPP_LAND
      CALL MPP_READ_SIMP_GW(IX,JX,IXRT,JXRT,GWSUBBASMSK,gwbasmskfil,&
              gw_strm_msk,numbasns,ch_netrt,AGGFACTRT)
#else
      CALL READ_SIMP_GW(IX,JX,IXRT,JXRT,GWSUBBASMSK,gwbasmskfil,&
              gw_strm_msk,numbasns,ch_netrt,AGGFACTRT)
#endif
       allocate (qout_gwsubbas (numbasns))
       allocate (qin_gwsubbas (numbasns))
       allocate (z_gwsubbas (numbasns))
       allocate (gwbas_pix_ct (numbasns))
       allocate (ct2_bas (numbasns))
       allocate (bas_pcp (numbasns))
       allocate (gw_buck_coeff (numbasns))
       allocate (gw_buck_exp(numbasns))
       allocate (z_max (numbasns))

!Temporary hardwire...
      z_gwsubbas = 1.     ! This gets updated with spun-up GW level in GWBUCKPARM.TBL

#ifdef MPP_LAND
   if(my_id .eq. IO_id) then
#endif
!Read in GW bucket params and Zinit from input file in Run directory...
     open (unit=81,file='GWBUCKPARM.TBL',status='old',   &
           form='formatted')
     read(81,811) header
811   FORMAT(A19)
     do bas = 1,numbasns
       read(81,812) gw_buck_coeff(bas),jnk,gw_buck_exp(bas),jnk,z_max(bas),&
             jnk,z_gwsubbas(bas)
812   FORMAT(F6.4,A1,F6.4,A1,F6.4,A1,F6.4)
     end do
     close(81)
#ifdef MPP_LAND
   endif
   call mpp_land_bcast_real(numbasns,gw_buck_coeff)
   call mpp_land_bcast_real(numbasns,gw_buck_exp  )
   call mpp_land_bcast_real(numbasns,z_max   )
   call mpp_land_bcast_real(numbasns,z_gwsubbas   )
#endif

!!! Determine number of stream pixels per GW basin for distribution...

#ifdef MPP_LAND
         call pix_ct_1(gw_strm_msk,ixrt,jxrt,gwbas_pix_ct,numbasns)
#else
         gwbas_pix_ct = 0.
         do bas = 1, numbasns
         do i=1,ixrt
           do j=1,jxrt
             if (gw_strm_msk(i,j).eq.bas) then
                 gwbas_pix_ct(gw_strm_msk(i,j)) = gwbas_pix_ct(gw_strm_msk(i,j)) &
                     + 1.0
             endif
           end do
         end do
         end do
#endif

    print *, "Starting GW basin levels...",z_gwsubbas

    End if

    If (GWBASESWCRT.EQ.2) Then   ! Call wedge aquifer scheme
    End if


    If (GWBASESWCRT.EQ.3) Then   ! Call TOPLATS GW/baseflow scheme
    End if

  END IF
!---------------------------------------------------------------------
!DJG  End if GW/Baseflow activated...
!----------------------------------------------------------------------



!---------------------------------------------------------------------
!DJG,DNY  If channel routing activated...
!----------------------------------------------------------------------
!   write(my_id+20,*) "step 3", my_id

  IF (CHANRTSWCRT.EQ.1 .or. CHANRTSWCRT .eq. 2) THEN

!---------------------------------------------------------------------
!DJG,DNY  Initalize lake and channel heights, this may be overwritten by RESTART
!--------------------------------------------------------------------

       if (channel_option .eq. 3) then
#ifdef MPP_LAND
        CALL mpp_CHAN_PARM_INIT (BOTWID,HLINK_INIT,CHAN_SS,CHMann)  !Read chan parms from table...
#else
        CALL CHAN_PARM_INIT (BOTWID,HLINK_INIT,CHAN_SS,CHMann)  !Read chan parms from table...
#endif
       end if

        do j=1,NLINKS
           if (channel_option .ne. 3) then
            if (TYPEL(j) .eq. 1) then !- for sparse network method this is a lake  (type 0 is river)
              RESHT(j) = LAKEMAXH(j) * 0.935  !-- assumes lake is ~90%
            endif
           else !-- parameterize according to order of diffusion scheme, or if read from hi res file, use its value
                !--  put condition within the if/then structure, which will assign a value if something is missing in hi res

             if (ORDER(j) .eq. 1) then    !-- smallest stream reach
               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(ORDER(j))
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(ORDER(j))
               endif
               if(MannN(j) .eq. 0.0) then 
                MannN(j) = CHMann(ORDER(j))
               endif
               HLINK(j) = HLINK_INIT(ORDER(j))
             elseif (ORDER(j) .eq. 2) then
               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(ORDER(j))
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(ORDER(j))
               endif
               if(MannN(j) .eq. 0.0) then 
                MannN(j) = CHMann(ORDER(j))
               endif
               HLINK(j) = HLINK_INIT(ORDER(j))
             elseif (ORDER(j) .eq. 3) then
               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(ORDER(j))
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(ORDER(j))
               endif
               if(MannN(j) .eq. 0.0) then 
                MannN(j) = CHMann(ORDER(j))
               endif
               HLINK(j) = HLINK_INIT(ORDER(j))
             elseif (ORDER(j) .eq. 4) then
               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(ORDER(j))
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(ORDER(j))
               endif
               if(MannN(j) .eq. 0.0) then 
                MannN(j) = CHMann(ORDER(j))
               endif
               HLINK(j) = HLINK_INIT(ORDER(j))
             elseif (ORDER(j) .eq. 5) then
               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(ORDER(j))
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(ORDER(j))
               endif
               if(MannN(j) .eq. 0.0) then 
                MannN(j) = CHMann(ORDER(j))
               endif
               HLINK(j) = HLINK_INIT(ORDER(j))
             elseif (ORDER(j) .eq. 6) then
               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(ORDER(j))
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(ORDER(j))
               endif
               if(MannN(j) .eq. 0.0) then 
                MannN(j) = CHMann(ORDER(j))
               endif
               HLINK(j) = HLINK_INIT(ORDER(j))
             elseif (ORDER(j) .ge. 7) then
               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(ORDER(j))
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(ORDER(j))
               endif
               if(MannN(j) .eq. 0.0) then 
                MannN(j) = CHMann(ORDER(j))
               endif
               HLINK(j) = HLINK_INIT(ORDER(j))
             else   !-- the outlets won't have orders since there's no nodes, so
                    !-- assign the order 5 values

               if(Bw(j) .eq. 0.0) then 
                Bw(j) = BOTWID(5)
               endif
               if(ChSSlp(j) .eq. 0.0) then  !if id didn't get set from the hi res file, use the  CHANPARAM
                ChSSlp(j) = CHAN_SS(5)
               endif
              if(MannN(j) .eq. 0.0) then 
               MannN(j) = CHMann(5)
               endif
               HLINK(j) = HLINK_INIT(5)
             endif
                
            CVOL(j) = (Bw(j)+ 1/ChSSLP(j)*HLINK(j))*HLINK(j)*CHANLEN(j) !-- initalize channel volume
           endif  !Endif channel option eq 3
        end do

        if (channel_option .eq. 3) then
           do j=1,NLAKES
             RESHT(j) = LAKEMAXH(j) * 0.99   !-- lake is 99% full at start
           end do
        endif

!--------------------------------------------------------------------
  END IF     ! Endif for channel routing setup
!-----------------------------------------------------------------------



!----------------------------------------------------------------------
! Initialize LSM Model State
!----------------------------------------------------------------------

!KWM         CALL READINIT(IX,JX,SMC,STC,SH2OX,ESDX,CMC,T1, SNODEP)
!KWM CALL READINIT_IHOP(DIR, IX, JX, NSOIL, SMC, STC, SH2OX, ESDX, CMC, T1, SNODEP)
!KWM  CALL READINIT_RTFDDA(IUNIT, IX, JX, NSOIL, OLDDATE, SMC, STC, SH2OX, CMC, T1, &
!KWM       WEASD, SNODEP)

#ifndef COUPLED
   SMC = 0.25
   STC = 282.0
   SH2OX = SMC
   CMC = 0.000025
   T1 = 282.0
   WEASD = 0.
   SNODEP = 0.
#ifdef MPP_LAND
     if(SNOW_ASSIM.eq.1) then
        CALL MPP_READSNOW_HRLDAS(trim(inflnm),IX, JX,trim(OLDDATE),WEASD,SNODEP,&
           global_nX, global_ny)
     endif

#else
   if(SNOW_ASSIM.eq.1) then
     CALL READSNOW_HRLDAS(inflnm,IX,JX,OLDDATE,WEASD,SNODEP)
   end if
#endif
#endif

!   write(my_id+20,*) "step 5"

!DJG Initialize additional soil layers (5-8) used in Noah-distrib.
!DJG  and adjust upper layers accordingly. This methodology assumes
!DJG  original init. data is coming from a 4 layer version of Noah
!DJG  as in EDAS or AFWA analyses.


!        print *, "debug soils...",SMC(100,100,1),SMC(100,100,2), &
!                    SMC(100,100,3),SMC(100,100,4),SMC(100,100,5), &
!                    SMC(100,100,6),SMC(100,100,8),SMC(100,100,8)

#ifndef COUPLED  
! coupled model will read hrldas output.

	DO J=1,JX
          DO I=1,IX
 	    l3moist=SMC(I,J,3)
 	    l4moist=SMC(I,J,4)
            SMC(I,J,8)=l4moist
            SMC(I,J,7)=l4moist
            SMC(I,J,6)=l4moist
            SMC(I,J,5)=l4moist
            SMC(I,J,4)=0.5*(l3moist+l4moist)
            SMC(I,J,3)=0.5*(l3moist+SMC(I,J,2))
 	    l3moist=SH2OX(I,J,3)
 	    l4moist=SH2OX(I,J,4)
            SH2OX(I,J,8)=l4moist
            SH2OX(I,J,7)=l4moist
            SH2OX(I,J,6)=l4moist
            SH2OX(I,J,5)=l4moist
            SH2OX(I,J,4)=0.5*(l3moist+l4moist)
            SH2OX(I,J,3)=0.5*(l3moist+SH2OX(I,J,2))
            l3temp=STC(I,J,3)
            l4temp=STC(I,J,4)
            STC(I,J,8)=0.5*(TBOT+l4temp)
            STC(I,J,7)=l4temp
            STC(I,J,6)=l4temp
            STC(I,J,5)=l4temp
            STC(I,J,4)=0.5*(l3temp+l4temp)
            STC(I,J,3)=0.5*(l3temp+STC(I,J,2))
          ENDDO
        ENDDO
#endif


! *** Read lai, fveg etc.
!KWM        CALL READVEG(IX,JX,FPAR,XLAI)
!KWM  CALL READVEG_IHOP(DIR,IX,JX,FPAR,LAI)
!KWM  CALL READVEG_RTFDDA(IUNIT, IX, JX, OLDDATE, VEGTYP, FPAR, LAI)

!   write(my_id+20,*) "step 6"

  if(FORC_TYP.eq.2) then
        inflnm = trim(indir)//"/"//&
             "wrfout_d02_"//&
             olddate(1:4)//"-"//olddate(6:7)//"-"//olddate(9:10)//&
             "_"//olddate(12:13)//":00:00"
        print *, inflnm
  end if


#ifdef MPP_LAND
!DJG_DES  CALL MPP_READVEG_HRLDAS(inflnm,ix,jx, OLDDATE, &
  DD = start_day
  MM = start_month
  CALL MPP_READVEG_HRLDAS(inflnm,trim(wrfsi_static_flnm),ix,jx, OLDDATE, &
         VEGTYP, FPAR, LAI,FORC_TYP,GREENFRAC, ALBEDO12M,MM,DD,  &
         global_nx,global_ny)
#else
!DJG_DES  CALL READVEG_HRLDAS(inflnm, IX, JX, OLDDATE, VEGTYP, FPAR, LAI,  &
  DD = start_day
  MM = start_month
  CALL READVEG_HRLDAS(inflnm,trim(wrfsi_static_flnm), IX, JX, OLDDATE, VEGTYP, FPAR, LAI,  &
         FORC_TYP,GREENFRAC, ALBEDO12M,MM,DD)
#endif


   write(6,*) "finish READVEG_HRLDAS"
   call flush(6)
!DJG now set in namelist file...  SLOPETYP = 8
   if(SLOPETYP .eq. 0) then
      SLOPETYP = 8
   endif

!  close(iunit)
!  rewind(iunit)

! Output in V3 format at time zero:
  SOILMX = -1.0 * SMC (:,:,1)* ZSOIL (1)
  DO K = 2,NSOIL
     SOILMX = SOILMX + SMC(:,:,K) * (ZSOIL (K-1) - ZSOIL (K))
  ENDDO
  SOILMX = SOILMX * 1.E3 ! Convert from m to mm
  HX = 0.0
  QFX = 0.0

!KWM  call output_rtfdda(ounit, hgrid, range, ix, jx, nsoil, sldpth, startdate, startdate, &
!KWM       vegtyp, soltyp, t1, cmc, stc, smc, sh2ox, soilmx, runoff1x, runoff2x, &
!KWM       runoff3x, etax, etakin, ecx, edirx, ettx, albedx, weasd, acrain, acsnom, &
!KWM       esnow2d, drip2d, dewfall, snodep, fpar, hx, qfx)
   INFXSWGT = 1./FLOAT(AGGFACTRT*AGGFACTRT)
   SH2OWGT = 1.

   flag = -1
#ifdef MPP_LAND
   if(my_id.eq.IO_id) then
      if (restart_hdate /= "") flag = 99
   endif 
   call mpp_land_bcast_int1(flag)
#else
   if (restart_hdate /= "") flag = 99
#endif

   if (flag.eq.99) then
!      print *, "Reading RESTART data...",restart_hdate,SMC(30,30,1)
      olddate = restart_hdate(1:16)

      call   RESTART_IN("RESTART."//olddate(1:16)//"_DOMAIN"//trim(hgrid), &
             SUBRTSWCRT,OVRTSWCRT,NSOIL,             &
             stc,smc,qfx,sh2ox,snodep,weasd,fx,etpx, &
             t1,etax,etakin,CMC,SOILHX,CHX,RUNOFF1X, &
             RUNOFF2X,RUNOFF3X,EDIRX,ECX,ETTX,RCX,HX,&
             SMCMAX1,SMCREF1,SMCWLT1,ALBEDX,ACRAIN,  &
             ACSNOM,ESNOW2D,DRIP2D,DEWFALL,SOILMX,   &
             SHORT,FPAR,                             &
             SFCHEADRT,INFXSWGT,SH2OWGT,ETPNDX ,INFXSRT,CHANRTSWCRT,&
#ifdef MPP_LAND
             nlinks_index,mpp_nlinks,lake_index,&
#endif
             nlinks,HLINK,CVOL,RESHT,QLAKEO, &
             LAKE_INFLORT,QSTRMVOLRT, &
             GWBASESWCRT,z_gwsubbas,ix,jx,ixrt,jxrt,rstrt_swc,numbasns)
             acrain_0 = acrain
     endif
     print *, "Reading RESTART data...",restart_hdate,z_gwsubbas
!     stop


!DJG Prepare Initial State Variables for Total Mass Balance Calculation
!	CMC_INIT=CMC
!	SWE_INIT=WEASD
!DJG Test for subsurface routing, (bogus) saturated initialization DEBUG...
!       do i=1,IX
!         do j=1,JX
!!             smc_init(I,J,1:NSOIL)=SMC(I,J,1:NSOIL)
!             SMC(I,J,1)=0.2
!             SMC(I,J,2)=0.2
!             SMC(I,J,3)=0.2
!             SMC(I,J,4)=0.339
!             SMC(I,J,5)=0.339
!             SMC(I,J,6)=0.339
!             SMC(I,J,7)=0.339
!             SMC(I,J,8)=0.339
!        end do
!       end do
!       SH2OX=SMC
!DJG End bogus initialization...



!DJG Output Initial Conditions...
  
#ifdef MPP_LAND
  flag  = -1
  if(my_id.eq.IO_id) then
     if (history_output) flag =99
  end if
  call mpp_land_bcast_int1(flag)
#ifdef COUPLED
  flag  = -1
#endif
  if(flag .eq.99) then
      call mpp_output_hrldas(.true.,global_nx,global_ny,ounit, igrid, &
          split_output_count, hgrid, range, ix, jx,            &
          nsoil, sldpth, startdate, olddate,                   &
          vegtyp, soltyp, t1, cmc, stc, smc, sh2ox,            &
          soilmx, runoff1x, runoff2x,                          &
          runoff3x, etax, etakin, ecx, edirx, ettx, albedx,    &
          weasd, acrain, acsnom,                               &
          esnow2d, drip2d, dewfall, snodep, fpar, hx,          &
          qfx, short, infxsrt, prcp_out,                       &
          etpndx,sfcheadrt,smcmax1,wrfsi_static_flnm ,FORC_TYP)

        if (HIRES_OUT.ge.1 .and. (SUBRTSWCRT.eq. 1 .or. OVRTSWCRT .eq. 1)) then
          call mpp_output_rt(igrid, split_output_count, ixrt, jxrt, &
          g_ixrt,g_jxrt, nsoil, &
          trim(startdate), trim(olddate), QSUBRT,ZWATTABLRT, & 
          SMCRT,SUB_RESID,       &
          q_sfcflx_x,q_sfcflx_y,soxrt,soyrt,QSTRMVOLRT,SFCHEADSUBRT, &
          trim(wrfsi_finegrid_flnm),DT,SLDPTH, latval, lonval,DXRT,HIRES_OUT)
        end if
  end if
#else
  print*, "step 1 history_output = ",history_output, DT
  if (history_output) then
     call output_hrldas(ounit, igrid, split_output_count,      &
          hgrid, range, ix, jx,                                &
          nsoil, sldpth, startdate, olddate,               &
          vegtyp, soltyp, t1, cmc, stc, smc, sh2ox, soilmx,    &
          runoff1x, runoff2x,                                  &
          runoff3x, etax, etakin, ecx, edirx, ettx, albedx,    &
          weasd, acrain, acsnom,                               &
          esnow2d, drip2d, dewfall, snodep, fpar, hx, qfx,     &
          short, infxsrt, prcp_out,                            &
          etpndx,sfcheadrt,smcmax1, wrfsi_static_flnm, FORC_TYP )
   print*, "return from step 1 history..."


      if (HIRES_OUT.ge.1) then
          call output_rt(igrid, split_output_count, ixrt, jxrt, nsoil, &
          startdate, olddate, QSUBRT,ZWATTABLRT,SMCRT,SUB_RESID,       &
          q_sfcflx_x,q_sfcflx_y,soxrt,soyrt,QSTRMVOLRT,SFCHEADSUBRT, &
          wrfsi_finegrid_flnm,DT,SLDPTH,LATVAL,LONVAL,DXRT,HIRES_OUT)
      end if

!          if (CHANRTSWCRT.eq.1 .or. CHANRTSWCRT .eq. 2) then 
!              call output_chrt(igrid, split_output_count, NLINKS, ORDER, &
!              startdate, olddate, CHLON,CHLAT, HLINK, ZELEV,QLINK,DT,K)
!  
!             if (NLAKES.gt.0) then 
!              call output_lakes(igrid, split_output_count, NLAKES, &
!              startdate, olddate, LATLAKE,LONLAKE,ELEVLAKE, QLAKEI, QLAKEO, &
!              RESHT,DT,K)
!             end if
!          end if

  endif
#endif



#ifdef COUPLED 
  NTIME = 1
#else
  NTIME=KHOUR*3600./nint(dt)
#endif

#ifdef MPP_LAND
  call mpp_land_bcast_int1(NTIME)
#endif

  write(6,*) "finish rtland_init"
  call flush(6)

#ifdef MPP_LAND
!  deallocate the global variable for parallel computation only.
!   call deallocate_global()
#endif


    return
    end subroutine rtland_init   


    subroutine run_rt_land(ntime,cpl_land_dt)
     implicit none
     real time1, time2, sumTime1,sumTime2
     integer ntime
     real cpl_land_dt
     real t1max, t1min

!------------------------------------------------------------------------
! Begin Time Loop
!------------------------------------------------------------------------
!DJG debug
      sumTime1 = 0
      sumTime2 = 0
 write(6, *) "Beginning time loop..."
 call flush(6)
! print *, "SLOPETYP", SLOPETYP
 

!A print*, "ywdebug :" ,my_id,igrid


!DJG Prepare Initial State Variables for Total Mass Balance Calculation
!#ifdef DEBUG_BALANCE
        cmc_init=CMC
	swe_init=WEASD
        do i=1,IX
          do j=1,JX
               smc_init=smc_init+(SMC(I,J,1)*100+SMC(I,J,2)*300   &
                +SMC(I,J,3)*300+SMC(I,J,4)*300+SMC(I,J,5)*300 &
                +SMC(I,J,6)*300+SMC(I,J,7)*300+SMC(I,J,8)*100)/float(IX*JX)
          end do
        end do
!#endif


#ifdef COUPLED
     NTIME = 1
     dt = cpl_land_dt 
     write(6,*) "yyww dt=",dt," dtrt=",dtrt
     call flush(6)
#endif

 if(dtrt .gt. dt) dtrt = dt

!DJG_DES  Assign check values for month changes to read in GREENFRAC and ALBEDO12M
  MM = 0
  DD = 0
  DD_chk = 0

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Begin Main Time Loop Here...
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  KLOOP : DO K=1,NTIME

  write(6,*)  "Running step ",K, " of Total Step ", NTIME
  call flush(6)

#ifdef COUPLED

  if(time_step_write_rstart) then   ! output restart 
      call   RESTART_OUT(trim(wrf_rstdate)//"REST",     &
             SUBRTSWCRT,OVRTSWCRT,NSOIL,              &
             stc,smc,qfx,sh2ox,snodep,weasd,fx,etpx,  &
             t1,etax,etakin,CMC,SOILHX,CHX,RUNOFF1X,  &
             RUNOFF2X,RUNOFF3X,EDIRX,ECX,ETTX,RCX,HX, &
             SMCMAX1,SMCREF1,SMCWLT1,ALBEDX,ACRAIN,   &
             ACSNOM,ESNOW2D,DRIP2D,DEWFALL,SOILMX,    &
             SHORT,FPAR,                              &
             SFCHEADRT,INFXSWGT,SH2OWGT,ETPNDX,INFXSRT, CHANRTSWCRT, &
#ifdef MPP_LAND
             nlinks_index,mpp_nlinks,lake_index,&
#endif
             nlinks,HLINK,CVOL,RESHT,QLAKEO, &
             LAKE_INFLORT,QSTRMVOLRT, &
             GWBASESWCRT,z_gwsubbas,ix,jx,ixrt,jxrt,numbasns)
  endif

  if(time_step_read_rstart) then   ! read restart 
      call   RESTART_IN(trim(wrf_rstdate)//"REST",     &
             SUBRTSWCRT,OVRTSWCRT,NSOIL,             &
             stc,smc,qfx,sh2ox,snodep,weasd,fx,etpx, &
             t1,etax,etakin,CMC,SOILHX,CHX,RUNOFF1X, &
             RUNOFF2X,RUNOFF3X,EDIRX,ECX,ETTX,RCX,HX,&
             SMCMAX1,SMCREF1,SMCWLT1,ALBEDX,ACRAIN,  &
             ACSNOM,ESNOW2D,DRIP2D,DEWFALL,SOILMX,   &
             SHORT,FPAR,                             &
             SFCHEADRT,INFXSWGT,SH2OWGT,ETPNDX ,INFXSRT,CHANRTSWCRT,&
#ifdef MPP_LAND
             nlinks_index,mpp_nlinks,lake_index,&
#endif
             nlinks,HLINK,CVOL,RESHT,QLAKEO, &
             LAKE_INFLORT,QSTRMVOLRT, &
             GWBASESWCRT,z_gwsubbas,ix,jx,ixrt,jxrt,rstrt_swc,numbasns)
  endif


  time_step_output = .false.

  if(time_step_output) then   ! regular output
      call mpp_output_hrldas(.true.,global_nx,global_ny,ounit, igrid, &
         split_output_count, hgrid, range, ix, jx, &
          nsoil, sldpth, wrf_outdate, wrf_outdate, &
          vegtyp, soltyp, t1, cmc, stc, smc, sh2ox, soilmx, runoff1x, runoff2x, &
          runoff3x, etax, etakin, ecx, edirx, ettx, albedx, weasd, acrain, acsnom, &
          esnow2d, drip2d, dewfall, snodep, fpar, hx, qfx, short, infxsrt, prcp_out, &
          etpndx,sfcheadrt,smcmax1,wrfsi_static_flnm,FORC_TYP)
  endif

#endif

! Read the forcing data.

! For HRLDAS, we're assuming (for now) that each time period is in a 
! separate file.  So we can open a new one right now.

      write(6,*) "before call read_seq_forcing"
      call flush(6)

 if(CHANRTSWCRT .ne. 2)   then  ! channel routing only (=2)

#ifndef COUPLED
#ifdef MPP_LAND
   call mpp_read_forcing( &
        indir,range,olddate,startdate,hgrid,DOY, &
        ix,jx,forc_typ,snow_assim,  &
        T2,q2x,u,v,pres,xlong,short,prcp1,&
        weasd,snodep,dt,k,global_nx,global_ny,igrid,acrain )
#else
   call read_seq_forcing( &
       indir,range,olddate,startdate,hgrid,DOY, &
       ix,jx,forc_typ,snow_assim,  &
       T2,q2x,u,v,pres,xlong,short,prcp1,&
       weasd,snodep,dt,k,igrid,acrain )
#endif

#endif

!       print *, "Before TER_ADJ_SOL..."
!!!DJG Adjust incoming solar radiation based on sloping terrain and aspect...
     IF (TERADJ_SOLAR.EQ.1) THEN   ! Perform terrain adjustment of incoming solar
       write(6,*) "Calling TER_ADJ_SOL..."
       call flush(6)
       call TER_ADJ_SOL(IX,JX,SO8LD_D,SO8LD_Vmax,SHORT,LATITUDE,LONGITUDE,olddate,DT)
      END IF

!DJG_DES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!DJG_DES Insert additional call to READVEG to update GREENFRAC and ALBEDO12M
!DJG_DES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    print *, "DJG_DES Made it here...." 
#ifdef MPP_LAND
   flag = -1
   if(my_id.eq.IO_id) then
      read(olddate(6:7),"(I2.2)") MM ! Day of the month
      read(olddate(9:10),"(I2.2)") DD ! Day of the month
      if (DD.ne.DD_chk) flag = 99
   endif 
   call mpp_land_bcast_int1(flag) 

!   write(my_id+90,*) "flag=",flag
!   call flush(my_id+90)

     if (flag .eq. 99) then   ! Get new GREENFRAC and ALBEDO12M values only if month changes...
       CALL MPP_READVEG_HRLDAS(inflnm,trim(wrfsi_static_flnm),ix,jx, OLDDATE, &
         VEGTYP, FPAR, LAI,FORC_TYP,GREENFRAC, ALBEDO12M,MM,DD,  &
         global_nx,global_ny)
       DD_chk =DD 
     end if
#else
     read(olddate(6:7),"(I2.2)") MM ! Day of the month
     if (DD.ne.DD_chk) then   ! Get new GREENFRAC and ALBEDO12M values only if month changes...
       CALL READVEG_HRLDAS(inflnm,trim(wrfsi_static_flnm), IX, JX, OLDDATE, VEGTYP, FPAR, LAI,  &
         FORC_TYP,GREENFRAC, ALBEDO12M,MM,DD)
       DD_chk = DD
     end if
#endif


     call time_seconds(time1)

!------------------------------------------------------------------------
! Spatial Loop to Convert Gridded data to single point for 1-D SFLX call
!------------------------------------------------------------------------

!DJG debug
     write(6,*) "Beginning space loop..."

     call flush(6)
     
!DJG Debug...
!    do i=1,IX
!      do j=1,JX
!        suminfxs1=suminfxs1+SFCHEADRT(I,J)
!      end do
!    end do
!    print *, "Total amt of sfc water before space loop :", suminfxs1
!    suminfxs1=0.

     JLOOP : DO J=1,JX ! max(JX-1,1)
        ILOOP : DO I=1, IX ! max(IX-1,1)
           IF (BASIN_MSK(I,J).EQ.-9999) GOTO 967 !Generic check for basin msk...
           kprint = .FALSE.
           IF((VEGTYP(I,J).GT.0).AND.(VEGTYP(I,J).NE.16)) THEN
              VEGTYPX=VEGTYP(I,J)
              SOILTYP=SOLTYP(I,J)
!             VEGTYPX = 8  !for debug...
!             SOILTYP = 13 !for debug...
              IF((SOILTYP.LE.0).OR.(SOILTYP.GE.19).OR.(SOILTYP.EQ.14)) THEN
                print *, i,j,SOILTYP,VEGTYPX
                STOP "PROBLEM with SOILS"
              ENDIF

              SFCTMP=T2(I,J)
              SFCSPD=SQRT(U(I,J)*U(I,J)+V(I,J)*V(I,J))
              SFCPRS=PRES(I,J)
              Q2=Q2X(I,J)
              PRCP=PRCP1(I,J)
!DJG

              if (prcp < 0.0) prcp = 0.0 ! Just in case
              SOLDN=SHORT(I,J)
              LWDN=XLONG(I,J)

             !
             ! The following module variables are set in subroutine REDPRM.
             ! If you want other than the default values based on land/soil
             ! categories, reset them after the call to REDPRM.
             !
             !    -- SOIL PARAMETERS:
             !
             !           CSOIL
             !           BEXP
             !           DKSAT (DJG-  'VERTKSAT' in dsitrNoah driver)
             !           DWSAT
             !           F1
             !           PSISAT
             !           QUARTZ
             !           SMCDRY
             !           SMCMAX
             !           SMCREF
             !           SMCWLT
             !
             !    -- "UNIVERSAL" PARAMETERS:
             !
             !           ZBOT
             !           SALP
             !           SBETA
             !           REFDK
             !           FRZK
             !           FXEXP
             !           REFKDT
             !           PTU
             !           KDT
             !           CZIL
             !           REFMANN  !mannings coefficient  scaling factor
             !           SLOPE
             !           FRZFACT
             !           MA
             ! 
             !    -- VEGETATION PARAMETERS:
             !
             !           TOPT
             !           RGL
             !           RSMAX
             !           RSMIN
             !           HS
             !           XLAI
             !           CMCMAX
             !           CFACTR
             !           NROOT
             !           SNUP
             !           ALB
             !           Z0BRD
             !           SHDFAC
             !           SNOALB_NOAH
             !           EMISSI
             !           RTDIS
             !

!DJG         Temp hardwire specification of LKSAT
             CALL REDPRM (VEGTYPX,SOILTYP,SLOPETYP,SLDPTH,NSOIL,VERTKSAT)

!DJG_DES   Overwrite REDPRM pixel values of GREENFRAC and ALBEDO from time-varying grids input above
             SHDFAC = GREENFRAC(I,J)
             FPAR(I,J) = GREENFRAC(I,J)  !Should only be relevant for output....
             ALBBRD = ALBEDO12M(I,J)


!DJG Specify Lateral Sat. Hyd. Conductivity (Note: LKSAT gets scaled upon disaggregation...)
              LKSAT(I,J) = VERTKSAT


!              XLAI =LAI(I,J)
!DJG_DES              SHDFAC = FPAR(I,J)

!   scaling MAXI LAI by Veg. fraction

              XLAI = MAX(XLAI*SHDFAC, 0.01) 

!   snow albedo
              alb = albbrd !?
              albedo = alb !?
              SNOFAC=MIN(SNODEP(I,J)*5.0, 1.0)
              ALBED=ALBEDO+(1.0-FPAR(I,J))*SNOFAC*(0.55-ALBEDO)
!   Net downward radiation
!              F= SRAD*(1.0-ALBED)+LWDN
!   
              CH = 0.1
              CM = 0.1
!-- modify mannings to be adjustable by a global scalar (to help calibration of channel)
              MannN = MannN * REFMANN


#ifdef COUPLED
              Z0 = z0_wrf(i,j)
              ZLVL = ZLVL_WRF(i,j)
#else
              Z0 = Z0BRD
#endif
!     Calculate a saturation mix ratio
              CALL CALTMP(T1(I,J), SFCTMP, SFCPRS, ZLVL, Q2, TH2, T1V, TH2V, RHO)
              CALL CALHUM(SFCTMP, SFCPRS, Q2SAT, DQSDT2)

!     Calculate the surface exchange coefficients CM, CH
              ! Intent (IN) :: ZLVL, Z0, T1V, TH2V, SFCSPD, CZIL
              ! Intent (INOUT) :: CM
              CALL SFCDIF_off (ZLVL,Z0,T1V,TH2V,SFCSPD,CZIL,CM,CH)                  

              IF (Q2 .LT. 0.0) THEN
!                print*,'Q2<0','I=',I, 'J=',J
                 Q2=.1E-5
              ENDIF
              IF (Q2 .GT. Q2SAT) THEN
                 ! print*, 'Q2 .GT. Q2SAT', 'I=',I, 'J=',J
                 ! print*,'Q2=',Q2,'Q2SAT=',Q2SAT
                 Q2=Q2SAT*0.99
              ENDIF


              CHKFF = CH * CPHEAT * RHO           


!DJG debug Insert check to insure that SMC <= 0.95*SMCMAX at first time step only...
! DJG then print output from initial cond...
!             if (K.eq.1) THEN
!               if (SMC(I,J).ge.SMCMAX) SMC(I,J)=0.95*SMCMAX
!             end if

#ifdef COUPLED
              TBOT = TBOT_WRF(i,j)
#endif
              STC1(1:NSOIL)=STC(I,J,1:NSOIL)
              SMC1(1:NSOIL)=SMC(I,J,1:NSOIL)
              SH2O(1:NSOIL)=SH2OX(I,J,1:NSOIL)
              ZSOILX(I,J,1:NSOIL)=ZSOIL(1:NSOIL)
! *** diagnostics 
              SFCSPDX(I,J)=SFCSPD


!--- Other conversions 'History (State) Variables

              CMCX=CMC(I,J)
              T1X=T1(I,J)
              SNOWH=SNODEP(I,J)

#ifdef    COUPLED
              SNEQV = WEASD(I,J) * 0.001
#else
              SNEQV = WEASD(I,J)
#endif
!yw added for possible bug
              if(SNEQV .ne. 0 .and. SNOWH .eq. 0)then
                 write(6,*) "yyyywww warning: SNEQV=",SNEQV, &
			"SNOWH=",SNOWH
                 SNEQV = 0   
              endif
!yw
              shdmin = 0.0

              esnow = 0.0

!DJG   Convert two gridded routing vars to single pts
              SFHEAD1RT = SFCHEADRT(I,J)
              INFXS1RT =0.0

!DJG Debug... Check Mass bal before SFLX call...
!     PRCP=0.
!     prcp_in=PRCP*DT+SFHEAD1RT
!     CMC1=CMCX*1000.
!     chcksm1=SH2O(1)*100+SH2O(2)*300+SH2O(3)*300+SH2O(4)*300+SH2O(5)*300 &
!               +SH2O(6)*300+SH2O(7)*300+SH2O(8)*100
!     print *, "Before SFLX...SH2O,SFHEAD",chcksm1,prcp_in,sfhead1rt
!
!DJG debug
!   write(6,*) "Calling subroutine SFLX...", I,J,SOLTYP(I,J),VEGTYP(I,J)
!    call flush(6)
!   write(6,*) "Calling subroutine SFLX...", I,J,SOLTYP(I,J),VEGTYP(I,J),&
!    ICE,DT,ZLVL,NSOIL,SLDPTH,LWDN,SOLDN,SFCPRS,PRCP,SFCTMP,Q2,SFCSPD,&
!    COSZ,PRCPRAIN, SOLARDIRECT,TH2,Q2SAT,DQSDT2,&
!    VEGTYPX,SHDMIN,SHDMAX,SFHEAD1RT,TBOT,Z0,&
!    CMCX,T1X,STC1,SMC1,SH2O,SNOWH,SNEQV,ALBEDO,CH,CM
!    call flush(6)


              CALL SFLX_RT (ICE,DT,ZLVL,NSOIL,SLDPTH,                  &
                   LWDN,SOLDN,SFCPRS,PRCP,SFCTMP,Q2,SFCSPD,         &    !F
                   COSZ,PRCPRAIN, SOLARDIRECT,                      &    !F
                   TH2,Q2SAT,DQSDT2,                                &    !I
                   VEGTYPX,SHDMIN,SHDMAX,SFHEAD1RT,                 &    !I  
                   SHDFAC,ALBBRD,                                   &    !I DJG_DES time-var params
                   TBOT,Z0,                                         &    !S   
!DJG_DES possible error in ALBEDO...     CMCX,T1X,STC1,SMC1,SH2O,SNOWH,SNEQV,ALBEDO,CH,CM,&    !H  
                   CMCX,T1X,STC1,SMC1,SH2O,SNOWH,SNEQV,ALBEDO,CH,CM,&    !H  
!! ----------------------------------------------------------------------         
!! OUTPUTS, DIAGNOSTICS, PARAMETERS BELOW GENERALLY NOT NECESSARY WHEN            
!! COUPLED WITH E.G. A NWP MODEL (SUCH AS THE NOAA/NWS/NCEP MESOSCALE ETA         
!! MODEL).  OTHER APPLICATIONS MAY REQUIRE DIFFERENT OUTPUT VARIABLES.            
!! ----------------------------------------------------------------------         
                   ETA,SHEAT, ETA_KINEMATIC,FDOWN,                  &    !O  
                   EC,EDIR,ET,ETT,ESNOW,DRIP,DEW,                   &    !O  
                   BETA,ETP,SSOIL,                                  &    !O  
                   FLX1,FLX2,FLX3,                                  &    !O  
                   SNOMLT,SNCOVR,                                   &    !O  
                   RUNOFF1,RUNOFF2,RUNOFF3,                         &    !O  
                   RC,PC,RCS,RCT,RCQ,RCSOIL,                        &    !O  
                   SOILW,SOILM,Q1,ETPND1,INFXS1RT)


!DJG debug
!    write(6,*) "Returned from SFLX..ETP,EDIR,ETPND1,ETT",ETP,EDIR,ETPND1,ETT
!DJG_DES   if (i.eq.30.AND.j.eq.30) then
!    write(6,*) "After SFLX check...shd,fpar,green",SHDFAC,    &
!                FPAR(I,J),GREENFRAC(I,J)
!    call flush(6)
!   end if

!---------------------------------------------------------------------
! Begin Converting Data back to grid from 1-d and make units conversions
!---------------------------------------------------------------------


!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     CONVERT ACTUAL EVAPOTRANSPIRATION VALUE FROM  KG M-2 S-1  TO
!     W M-2  (BY MULTIPLYING BY 2.501E+6) FOR USE IN ENERGY BALANCE.
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
              T14 = T1X * T1X * T1X * T1X
              AET = ETA
              FUP = 5.67E-8 * T14
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!     CALCULATE RESIDUAL OF ALL SURFACE ENERGY BALANCE EQN TERMS.
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
              S = -S
!FC              RESX(I,J) = F - H - S - AET - FUP - FLX1 - FLX2 - FLX3
!KWM              SNOFLX=FLX3
!  Convert ETA and ETP from W M-2 to KG M-2 S-1

#ifdef COUPLED
! added by yw
       LH_yw(i,j) = ETA
       SOILW_yw(I,J)=SOILW
       SOILM_yw(I,J)=SOILM*1000.
!end  yw
#endif

!KWM              ETA = ETA/2.501E+6

              ETP = ETP/2.501E+6  

              QFX(I,J) = (EDIR+EC+ETT+ETPND1) + ESNOW ! in W m{-2}

!KWM Overwrite ETA for now
              ETA = ((EDIR+EC+ETT+ETPND1)/2.501E+6) + (ESNOW/2.83E6)

! Fill output variable arrays and doing output

              STC(I,J,1:NSOIL)=STC1(1:NSOIL)    ! Updated Soil Temperature
              SMC(I,J,1:NSOIL)=SMC1(1:NSOIL)    ! Updated Soil Moisture
              SH2OX(I,J,1:NSOIL)=SH2O(1:NSOIL)  ! Updated Soil Liquid Water
              SNODEP(I,J)=SNOWH                 ! Updated snow depth !KWM
              WEASD(I,J)=SNEQV      ! ( m of water )
              ETPX(I,J)=ETPX(I,J)+ETP*dt  ! ( kg m{-2} s{-2} to mm)
              ETAKIN(I,J)=ETA_KINEMATIC*dt
#ifdef COUPLED
              ZNT(I,J)=Z0
              SNOWC(I,J)=SNCOVR
              ETPX(I,J)=ETPX(I,J)+ETP  ! ( kg m{-2} s{-2} to mm)
              ETAKIN(I,J)=ETA_KINEMATIC
              QSFC(I,J)=Q1   ! added by yw for coupling with wrf
#endif
              FX(I,J)=FDOWN
!orig              ETPX(I,J)=ETP
              T1(I,J)=T1X
              ETAX(I,J)=ETAX(I,J)+ETA*dt ! kg m{-2} s{-1} to mm liquid
              CMC(I,J)=CMCX
              SOILHX(I,J)=SSOIL
              CHX(I,J)=CH
              RUNOFF1X(I,J)=RUNOFF1X(I,J)+RUNOFF1*dt*1.E3     ! ( mm/s to mm)
              RUNOFF2X(I,J)=RUNOFF2X(I,J)+RUNOFF2*dt*1.E3     ! ( mm/s to mm)
              RUNOFF3X(I,J)=RUNOFF3X(I,J)+RUNOFF3*dt*1.E3     ! ( mm/s to mm)
              EDIRX(I,J)=EDIRX(I,J)+(EDIR/2.501E6)*dt ! (W m{-2} to kg m{-2} s{-2} to mm)
              ECX(I,J)=ECX(I,J)+(EC/2.501E6)*dt       ! (W m{-2} to kg m{-2} s{-2} to mm)
              ETTX(I,J)=ETTX(I,J)+(ETT/2.501E6)*dt    ! (W m{-2} to kg m{-2} s{-2} to mm)
!KWM              SNMAXX(I,J)=SNMAX
!KWM              SNOFLXX(I,J)=SNOFLX
!FC             SNOEVPX(I,J)=SNOEVP
              RCX(I,J)=RC
              HX(I,J)=SHEAT
              SMCMAX1(I,J)=SMCMAX
              SMCREF1(I,J)=SMCREF
              SMCWLT1(I,J)=SMCWLT
              ALBEDX(I,J)=ALBEDO
              ACRAIN(I,J)=ACRAIN(I,J)+PRCP*dt      ! (mm/s to mm)
!DJG
!              if (I.EQ.263.AND.J.EQ.15) print *, "debug2...PRCP1=",PRCP1(263,15),PRCP
              PRCP_OUT(I,J)=PRCP*dt      ! (mm/s to mm)
              ACSNOM(I,J)=ACSNOM(I,J)+snomlt*1.E3  ! Accumulated snow melt in mm
              ! Accumulated snow sublimation (converted from W m{-2} to kg m{-2} s{-2} to mm)
              ESNOW2D(I,J)=ESNOW2D(I,J)+(ESNOW/2.83E6)*dt
              DRIP2D(I,J)=DRIP2D(I,J)+DRIP*1.E3   ! convert m to mm
              DEWFALL(I,J)=DEWFALL(I,J)+DEW*1.E3  ! convert m to mm
              SOILMX(I,J)= SOILM*1.E3             ! convert m to mm
              EMISS(I,J) = EMISSI

!DJG Convert from point to grid (units of SFHEAD & INFXS (mm))
!             INFXSRT(I,J)=PRCP1(I,J)     ! Use this for 'parking lot' sim
              INFXSRT(I,J)=INFXS1RT     ! Use this as default
              SOLDRAIN(I,J)=RUNOFF2*dt*1.E3
!              SFCHEADRT(I,J) = INFXSRT(I,J) ! Use ONLY if testing re-infil w/out routing
!DJG Debug...
!             IF (INFXS1RT.ne.0.) then
!              print *, "@@@@@ INFXSRT <> 0. at:",i,j,INFXS1RT
!             END IF

              ETPNDX(I,J)=ETPNDX(I,J)+(ETPND1/2.501E6)*dt ! (W m{-2} to kg m{-2} s{-2} to mm)
!DJG Accumulate INFXSRT as a check to compare with sfcrnoff...
              INFXSRTOT = INFXSRTOT+INFXS1RT
	      RNOF1TOT = RNOF1TOT+RUNOFF1*dt*1.E3
	      RNOF2TOT = RNOF2TOT+RUNOFF2*dt*1.E3
	      RNOF3TOT = RNOF3TOT+RUNOFF3*dt*1.E3
              ETATOT = ETATOT+ETA*dt



	     if (vegtyp(i,j).ne.16) vegct=vegct+1
! ***  endif of the land-point
           ENDIF
!           write (*,*) "end of single point processing..."

!DJG debug... 
!     CMC2=CMCX*1000.
!     chcksm2=SH2O(1)*100+SH2O(2)*300+SH2O(3)*300+SH2O(4)*300+SH2O(5)*300 &
!               +SH2O(6)*300+SH2O(7)*300+SH2O(8)*100
!     dsmctot=chcksm2-chcksm1
!     dcmc=CMC2-CMC1
!     resid=prcp_in-ETA*DT-dsmctot-dcmc-infxs1rt-RUNOFF3*dt*1.E3
!     resid2=resid2+resid/float(IX*JX)
!    IF (ABS(resid).gt.0.001) then
!!     print *, "SH20:",chcksm2,CMC2-CMC1
!     print *, "Terms: PCP,ETA,DSMC,DCMC,INFXS1RT,RUNOFF3,resid",I,J
!     print *, "Out",prcp_in,ETA*DT,dsmctot,dcmc,INFXS1RT,RUNOFF3*dt*1.E3,RESID
!     print *
!    End if

967     CONTINUE   ! (For COWS watershed mask)
        ENDDO ILOOP
     ENDDO JLOOP

!DJG debug
  print *, "End Space loop... "
   IF (DEEPGWSPIN.EQ.1) THEN
     IF (K.eq.1) SMC = SMCMAX   ! Set to Saturation for spin-up of deep gw routing...
   END IF 
!-------------------------------------------------------------------
! END of 1-D NOAH processing
!-------------------------------------------------------------------

!-------------------------------------------------------------------
!DJG Begin Disagg & Terrain Routing Routines
!-------------------------------------------------------------------

  IF (SUBRTSWCRT.EQ.1.OR.OVRTSWCRT.EQ.1) THEN

!DJG Mass balance check to/from terrain routing...
!        print *, "Domain Averaged Mass Balance Information (Routing):"
!        print *, IX,JX,IXRT,JXRT
!        dsmc=0.
!        suminfxs1=0.
!        chan_in1=0.
!        chan_out =0.
!        lake_in1=0.
!        do i=1,IX
!          do j=1,JX
!            do kx=1,nsoil
!              dsmc(kx)=dsmc(kx)+smc(i,j,kx)
!            end do
!            suminfxs1=suminfxs1+INFXSRT(I,J)/float(IX*JX)
!          end do
!        end do
!           smctot1=(dsmc(1)*100+dsmc(2)*300+dsmc(3)*300   &
!                   +dsmc(4)*300+dsmc(5)*300+dsmc(6)*300 &
!                   + dsmc(7)*300+dsmc(8)*100)/float(IX*JX)
!        do i=1,IXRT
!         do j=1,JXRT
!            chan_in1=chan_in1+QSTRMVOLRT(I,J)/float(IXRT*JXRT)
!            lake_in1=lake_in1+LAKE_INFLORT(I,J)/float(IXRT*JXRT)
!         end do
!        end do
!       print *, "Before Routing...",smctot1,suminfxs1,chan_in1,lake_in1

     QSTRMVOLRT_DUM = QSTRMVOLRT
     LAKE_INFLORT_DUM = LAKE_INFLORT

     write(6,*) "Before Routing"
     call flush(6)

     call drive_RT( IX,JX,NSOIL,IXRT,JXRT,  &
       SMC,STC,SH2OX,SICE, INFXSRT,SFCHEADRT,SMCMAX1,SMCREF1,LKSAT,  &
       SMCWLT1, SMCRTCHK,DSMC,ZSOIL, SMCAGGRT,STCAGGRT,SH2OAGGRT, &
       SLDPTH,VEGTYP,SOLDEPRT,INFXSAGGRT,DHRT,QSTRMVOLRT, &
       QBDRYRT,LAKE_INFLORT,SFCHEADSUBRT,INFXSWGT,LKSATRT, &
       INFXSUBRT,OVROUGHRT,QSUBRT,ZWATTABLRT,QSUBBDRYRT,   &
       RETDEPRT,SOXRT,SOYRT,SUB_RESID,SMCRT,SMCMAXRT,SMCWLTRT, &
       SH2OWGT,LAKE_MSKRT,CH_NETRT, dxrt,LSMVOL,DSMCTOT,SMCTOT1,&
       SMCTOT2,suminfxs1,suminfxsrt,SO8RT,SO8RT_D,k,AGGFACTRT,  &
       SUBRTSWCRT,OVRTSWCRT, IXXRT, JYYRT, LAKE_CT, STRM_CT,    &
       RT_OPTION,OV_ROUGH,INFXSAGG1RT,SFCHEADAGG1RT,SFCHEADAGGRT,&
       WATHOLDCAP,DTRT, DT,LAKE_INFLOTRT,QBDRYTRT,QSUBBDRYTRT,&
       QSTRMVOLTRT,q_sfcflx_x,q_sfcflx_y,LKSATFAC  )

     call time_seconds(time2)
     sumTime1 = sumTime1 + (time2-time1) /60.0
#ifdef MPP_LAND
     if(my_id .eq. IO_id) then
        write(6,*) "yyww Routing land called with time(s):",time2-time1
        write(6,*) "Total Land Routing time(minute):",sumTime1
     end if
     write(6,*) "Finish Routing"
     call flush(6)
#else
     write(6,*) "yyww Routing land called with time(s):",time2-time1
     write(6,*) "Total Land Routing time(minute):",sumTime1
     write(6,*) "Finish Routing"
     call flush(6)
#endif

     QSTRMVOLRT_TS = QSTRMVOLRT-QSTRMVOLRT_DUM
     LAKE_INFLORT_TS = LAKE_INFLORT-LAKE_INFLORT_DUM
!DJG Mass balance check...
!        dsmc=0.
!        suminfxsrt=0.
!        chan_in2=0.
!        lake_in2=0.
!        do i=1,IX
!          do j=1,JX
!            do kx=1,nsoil
!              dsmc(kx)=dsmc(kx)+smc(i,j,kx)/float(IX*JX)
!            end do
!            suminfxsrt=suminfxsrt+SFCHEADRT(I,J)/float(IX*JX)
!          end do
!        end do
!           smctot2=(dsmc(1)*100+dsmc(2)*300+dsmc(3)*300   &
!                   +dsmc(4)*300+dsmc(5)*300+dsmc(6)*300 &
!                   +dsmc(7)*300+dsmc(8)*100)
!
!DJG  Do not comment out next 8 lines in order to calc sim. total mass bal.
        chan_in2=0.
        chan_inv = 0
        lake_inv =0 
     !  chan_out=0. 
        chan_stor=0.
        lake_in2=0.

        do i=1,IXRT
         do j=1,JXRT
             chan_in2=chan_in2+QSTRMVOLRT(I,J)/float(IXRT*JXRT)
             chan_inv = chan_inv+QSTRMVOLRT(I,J)/1000*(DXRT*DXRT)
             lake_in2=lake_in2+LAKE_INFLORT(I,J)/float(IXRT*JXRT)
             lake_inv = lake_inv+LAKE_INFLORT(I,J)/1000*(DXRT*DXRT)
         end do
        end do

!       print *, "After Routing...",smctot2,suminfxsrt,chan_in2,lake_in2
!       dsmctot = smctot2-smctot1
!       print *, "Change in Soil Moist:, ",dsmctot,smctot2,smctot1
!       print *, "Change in INFXS: ",suminfxsrt-suminfxs1,suminfxsrt,suminfxs1
!       print *, "Change in Chan_in: ",chan_in2-chan_in1
!       print *, "Change in Lake_in: ",lake_in2-lake_in1
!       print *, "Routing Residual : ", suminfxs1-suminfxsrt-(chan_in2-chan_in1) &
!                     -(lake_in2-lake_in1)
        print *, "Total Inflows + Storage:", chan_in2,lake_in2
        print *, "Total Vol In  + Storage:", chan_inv,lake_inv


  END IF    !DJG (End if for RTE SWC activation)
!------------------------------------------------------------------
!DJG End Disagg & Terrain Routing Routines
!------------------------------------------------------------------
  endif     ! for CHANRTSWCRT only (=2)

!------------------------------------------------------------------
!DJG Begin GW/Baseflow Routines
!-------------------------------------------------------------------

  IF (GWBASESWCRT.GE.1) THEN     ! Switch to activate/specify GW/Baseflow

    If (GWBASESWCRT.EQ.1) Then   ! Call simple bucket baseflow scheme
         DX = DXRT * AGGFACTRT
       print *, "calling simp_gw_buck...",DX
       call simp_gw_buck(ix,jx,ixrt,jxrt,numbasns,DX,&
                         gwsubbasmsk, SOLDRAIN, z_gwsubbas,&
                         qin_gwsubbas,qout_gwsubbas,qinflowbase,&
                         gw_strm_msk,gwbas_pix_ct,DXRT,DT,&
                         gw_buck_coeff,gw_buck_exp,z_max)

!Debug...,can comment out when working
       print *, "finish  simp_gw_buck...",DX

       do i=1,ixrt
         do j=1,jxrt
           if (qinflowbase(i,j).lt.0) then
            print *, "Error!!!baseflow > 0 ...", qinflowbase(i,j)
            call land_finish()
           end if
         end do
       end do
       

!!!For parameter setup runs output the percolation for each basin,
!!!otherwise comment out this output...

#ifdef MPP_LAND
      if(my_id .eq. IO_id) then
#endif

       open (unit=51,file='GW_inflow.txt',form='formatted',&
             status='unknown',position='append')
         write (51,*) (qin_gwsubbas(i),i=1,numbasns)
       close(51)

       open (unit=51,file='GW_outflow.txt',form='formatted',&
             status='unknown',position='append')
         write (51,*) (qout_gwsubbas(i),i=1,numbasns)
       close(51)

       open (unit=51,file='GW_zlev.txt',form='formatted',&
             status='unknown',position='append')
         write (51,*) (z_gwsubbas(i),i=1,numbasns)
       close(51)
#ifdef MPP_LAND
     endif
#endif

    End if


    If (GWBASESWCRT.EQ.2) Then   ! Call wedge aquifer scheme

    End if


    If (GWBASESWCRT.EQ.3) Then   ! Call TOPLATS GW/baseflow scheme

    End if

  END IF    !DJG (End if for RTE SWC activation)
!------------------------------------------------------------------
!DJG End GW/Baseflow Routines
!-------------------------------------------------------------------

!-------------------------------------------------------------------
!-------------------------------------------------------------------
!DJG,DNY  Begin Channel and Lake Routing Routines
!-------------------------------------------------------------------
  IF (CHANRTSWCRT.EQ.1 .or. CHANRTSWCRT.EQ.2) THEN
    print *, "Calling channel driver..."

     if(CHANRTSWCRT.EQ.2) then   !read channel inflow data for Channel Routing 
       print *, "Reading channel forcing data..."
       call read_chan_forcing( & 
       indir,range,olddate,startdate,hgrid,DOY, &
       ixrt,jxrt,QSTRMVOLRT,QINFLOWBASE,QSUBRT)
       QSTRMVOLRT_TS = QSTRMVOLRT-QSTRMVOLRT_DUM
       QSTRMVOLRT_DUM = QSTRMVOLRT
     end if  

    call drive_CHANNEL(K,IXRT,JXRT, SUBRTSWCRT, QSUBRT, &
       LAKE_INFLORT_TS, QSTRMVOLRT_TS, TO_NODE, FROM_NODE, TYPEL,&
       ORDER, MAXORDER, NLINKS, CH_NETLNK, CH_NETRT, LAKE_MSKRT, DT, DTRT, &
       MUSK, MUSX,  QLINK, HLINK, ELRT,CHANLEN,MannN,So, ChSSlp, Bw,&
       RESHT, HRZAREA, LAKEMAXH, WEIRC, WEIRL, ORIFICEC, ORIFICEA, &
       ORIFICEE, ZELEV, CVOL, NLAKES, QLAKEI, QLAKEO, LAKENODE, DXRT, &
       QINFLOWBASE, CHANXI, CHANYJ, channel_option, RETDEP_CHAN &
#ifdef MPP_LAND
       ,lake_index,link_location,mpp_nlinks,nlinks_index,yw_mpp_nlinks)
#else
       )
#endif
    write(6,*) "Returning from  channel driver..."

!dump sub-basin avg precip...
!         ct2_bas=0
!         bas_pcp=0.
!         do j=1,jx
!           do i=1,ix
!              if (GWSUBBASMSK(i,j).gt.0) then
!                ct2_bas(GWSUBBASMSK(i,j)) = ct2_bas(GWSUBBASMSK(i,j))+1
!                bas_pcp(GWSUBBASMSK(i,j)) = bas_pcp(GWSUBBASMSK(i,j))+ &
!                 ACRAIN(I,J)-ACRAIN_0(i,j)
!              end if
!           end do
!         end do

         ACRAIN_0 = ACRAIN
         
!        do bas=1,numbasns
!           bas_pcp(bas) = bas_pcp(bas)/ct2_bas(bas)
!         end do

        
        do i=1,NLINKS  !-- water stored in channel
            chan_stor = chan_stor + (Bw(i)+(1/ChSSLP(i)*HLINK(i)))*HLINK(i)*CHANLEN(i) !AREA = (Bw+z*h2)*h2        

           if(TO_NODE(i) .gt. 0) then
              if(TYPEL(TO_NODE(i)) .eq. 1) then !-- point just upstream of pour point
              ! print *,  i, QLINK(i,1), HLINK(i)
                chan_out = chan_out + QLINK(i,1)*DT
              endif
           endif

           !if(TYPEL(i) .ne. 0) then !-- point just upstream of pour point
           ! print *,  i, QLINK(i,1), HLINK(i)
           ! chan_out = chan_out + QLINK(i,1)*DT
           !endif

        end do

        print *, "Total Channel Storage:", chan_stor
        print *, "Total Outflow:", chan_out
         
  END IF    ! End if for channel routing option
!-------------------------------------------------------------------
!DJG End Channel and Lake Routing Routines
!-------------------------------------------------------------------


     call time_seconds(time2)  
     sumTime2 = sumTime2 + (time2-time1) /60.0
#ifdef MPP_LAND
     if(my_id .eq. IO_id) then
       write(6,*) "yyww Land and Channel Routing called with time(s):",time2-time1
       write(6,*) "Total Land & Channel Routing time(minute):",sumTime2
       call flush(6)
     end if
#else
     write(6,*) "yyww Land and Channel Routing called with time(s):",time2-time1
     write(6,*) "Total Land & Channel Routing time(minute):",sumTime2
     call flush(6)
#endif

!-------------------------------------------------------------------
!DJG Domain-Avg Cumulative Mass Balance Calculation...
!-------------------------------------------------------------------
	
	print *, "Domain Averaged Time-step Mass Balance Information:"
        smc_final=0.
        do i=1,IX
          do j=1,JX
            smc_final=smc_final+(SMC(I,J,1)*100+SMC(I,J,2)*300   &
                +SMC(I,J,3)*300+SMC(I,J,4)*300+SMC(I,J,5)*300 &
                +SMC(I,J,6)*300+SMC(I,J,7)*300+SMC(I,J,8)*100)/float(IX*JX)
            dcmc=dcmc+(cmc(i,j)-cmc_init(i,j))/FLOAT(IX*JX)
            dswe=dswe+(weasd(i,j)-swe_init(i,j))/FLOAT(IX*JX)
	    dacrain=dacrain+ACRAIN(i,j)/FLOAT(IX*JX)
            dprcp_ts=dprcp_ts+PRCP_OUT(i,j)/FLOAT(IX*JX)
            detp=detp+ETPX(i,j)/FLOAT(IX*JX)
	    dsfcevp=dsfcevp+etax(i,j)/FLOAT(IX*JX)
	    dcanevp=dcanevp+ecx(i,j)/FLOAT(IX*JX)
	    dedir=dedir+edirx(i,j)/FLOAT(IX*JX)
	    dett=dett+ettx(i,j)/FLOAT(IX*JX)
	    depnd=depnd+etpndx(i,j)/FLOAT(IX*JX)
	    desno=desno+esnow2d(i,j)/FLOAT(IX*JX)
            dsfcrnff=dsfcrnff+runoff1x(i,j)/FLOAT(IX*JX)
            dug1rnff=dug1rnff+runoff2x(i,j)/FLOAT(IX*JX)
            dug2rnff=dug2rnff+runoff3x(i,j)/FLOAT(IX*JX)
            dqbdry=dqbdry+QBDRYRT(i,j)/FLOAT(IX*JX)
           IF (SUBRTSWCRT.EQ.1.OR.OVRTSWCRT.EQ.1) THEN
            suminfxs1=suminfxs1+SFCHEADRT(I,J)/FLOAT(IX*JX)
           ELSE
            suminfxs1=suminfxs1+INFXSRT(I,J)/FLOAT(IX*JX)
           END IF
!           end if  !  (End if Veg chk)
          end do
        end do
 
!!DJG Output Change in state variables:
	dsmctot = (dsmc(1)+dsmc(2)+dsmc(3)+dsmc(4)   &
		+ dsmc(5)+dsmc(6)+dsmc(7)+dsmc(8))/FLOAT(IX*JX)
        dsmctot=smc_final-smc_init
        print *, "Change in Total Column Soil Moisture:", dsmctot
     


!!DJG Output accumulation variables:
        print *, 'Precipitation:', dacrain
	print *, 'Sfc Evap:', dsfcevp
	print *, 'Pot Evap:', detp
!        sumevp=dcanevp+dedir+dett+depnd+desno
!        print *, 'Total Evap Check:', sumevp
	print *, 'Can Evap:', dcanevp
	print *, 'Direct Evap:', dedir
	print *, 'Transpir. :', dett
	print *, 'Ponded Evap:', depnd
!	print *, 'Snow Evap:', desno
	print *, 'Sfc Runoff:', dsfcrnff
	print *, 'Ugr2 Runoff:', dug1rnff
	print *, 'Ugr3 Runoff:', dug2rnff
	print *, 'Chan_Inflo:', chan_in2
	print *, 'Lake_Inflo:', lake_in2
	print *, 'Boundry_Outflo:', dqbdry
	print *, 'Infxs:',suminfxs1

!!DJG Total Residual Calculation...
        IF (SUBRTSWCRT.EQ.1.OR.OVRTSWCRT.EQ.1) THEN
          resid1=dacrain-dsfcevp-dsmctot-dcmc-suminfxs1 &
                   -dug1rnff-dug2rnff-chan_in2-lake_in2
        ELSE
          resid1=dacrain-dsfcevp-dsmctot &
                   -dcmc-dsfcrnff-dug1rnff-dug2rnff
        END IF

	print *, 'Total Residual :',resid1
!	print *, 'Total Residual2 :',resid2
	print * 


!!DJG Reset mass bal check variables...
!        smc_final=0.
	dsmc=0.
	dswe=0.
	dcmc=0.
	dacrain=0.
	dsfcevp=0.
	detp=0.
	dcanevp=0.
	dedir=0.
	dett=0.
	depnd=0.
	desno=0.
	dsfcrnff=0.
        dug1rnff=0.
        dug2rnff=0.
        suminfxs1=0.
	vegct = 0.
        dprcp_ts=0.
        dqbdry=0.

!-------------------------------------------------------------------
!DJG End Time-Step Mass Balance Calculation...
!-------------------------------------------------------------------

!------------------------------------------------------------------------
! Call to Output thermodynamic variables
!------------------------------------------------------------------------
!KWM          CALL PRTHM(K,IX,JX,MDT,MINUTE,NSOIL,CHX,FX,SOILHX,                &
!KWM         CMC,T2,T1,ETAX,ETPX,PRCP1,STC,SMC,DT,HX,RESX)

!------------------------------------------------------------------------
! Call to Output hydrological variables
!------------------------------------------------------------------------
!KWM          CALL PRTHYD(K,IX,JX,NSOIL,MDT,MINUTE,ETAX,ETPX,PRCP1,             &
!KWM        SMC,ZSOIL,RUNOFF1X,RUNOFF2X,RUNOFF3X,DT,EDIRX,ECX,                &
!KWM	ETTX,CMC,SLDPTH,SNOEVPX,SH2OX,ESDX,SNODEP,VEGTYP) 
!FC        QBDRYT,QSTRMVOLT,QBDRY,QSTRMVOL,SFCHEAD,INFXS1,DH,                &
!FC        CH_NET,PDDUM2,PCPDRP,SFCWATR2,QLAKVOL,QLAKVOLT)

#ifdef tmp_MPP_LAND
#ifdef MPP_LAND
        if(my_id .eq. IO_id) then
             open(40,file='QSTRMVOL_TS.txt',form='unformatted',status='replace')
        endif
        call write_restart_rt_2(40,QSTRMVOLRT_TS)
        if(my_id .eq. IO_id) close(40)

        if(my_id .eq. IO_id) then
	   open(40,file='QSUBRT.txt',form='formatted',status='replace')
        endif
        call write_restart_rt_2(40,QSUBRT)
        if(my_id .eq. IO_id) close(40)
#else
        
	open(40,file='QSTRMVOL_TS.txt',form='formatted',status='replace')
         write (40,*) 'TIME=',K
         do i=1,IXRT
          do j=1,JXRT
            if (QSTRMVOLRT_TS(I,J).gt.0.) write (40,*) QSTRMVOLRT_TS(I,J)
          end do
         end do
        close(40)

	open(40,file='QSUBRT.txt',form='formatted',status='replace')
         write (40,*) 'TIME=',K
         do i=1,IXRT
          do j=1,JXRT
            if (QSUBRT(I,J).gt.0.) write (40,*) QSUBRT(I,J)
          end do
         end do
        close(40)


!COWS..dump stream inflow grid file
      if (FORC_TYP.eq.3) then  
        open(40,file='QSTRMVOL_ACC_GRD.txt',form='formatted',status='replace')
         write (40,*) 'TIME=',K
         do j=jxrt,1,-1
           write (40,696) (QSTRMVOLRT(i,j),i=1,ixrt)
696         FORMAT (600(F7.2,1X))
         end do
        close(40)
       end if 
#endif

#endif
!------------------------------------------------------------------------
! Update the time 
!------------------------------------------------------------------------

#ifdef MPP_LAND
   if(IO_id.eq.my_id) then
#endif
     call geth_newdate(newdate, olddate, nint(dt))
     olddate = newdate
#ifdef COUPLED
     write(*,*) "***DATE= ",wrf_outdate
#else
     write(*,'(" ***DATE=", A13, F10.5)') olddate, stc(1,1,1)
#endif

#ifdef MPP_LAND
   endif
#endif

!KWM! Output for restart
   flag = -1
#ifdef MPP_LAND
   if(IO_id.eq.my_id) then
      read(olddate(9:10),"(I2.2)") NS ! Day of the month
      if ( (olddate(12:16) == "00:00") .and. (mod(ns,1) == 0) ) then
!     if ( (olddate(12:13) == "00") .or. (olddate(12:13) == "06") .or. &
!           (olddate(12:13) == "12") .or. (olddate(12:13) == "18")) then 
!         if (olddate(15:16) == "00") then
!         if ((olddate(15:16) == "00").or.(olddate(15:16) == "15").or. &
!             (olddate(15:16) == "30").or.(olddate(15:16) == "45")) then
            flag = 99
         end if
!     endif
   endif

   call mpp_land_bcast_int1(flag)
   
#ifdef COUPLED
    flag = -1
#endif
#else
     read(olddate(9:10),"(I2.2)") NS ! Day of the month
     if ( (olddate(12:16) == "00:00") .and. (mod(ns,1) == 0) ) then
!     if ( (olddate(12:13) == "00") .or. (olddate(12:13) == "06") .or. &
!           (olddate(12:13) == "03") .or. (olddate(12:13) == "18")) then 
!          if (olddate(15:16) == "00") then
             flag = 99
!          endif
     endif
#endif
!             flag = 99

  if (flag .eq. 99 )  &
             call   RESTART_OUT("RESTART."//olddate(1:16)//"_DOMAIN"//trim(hgrid),     &
             SUBRTSWCRT,OVRTSWCRT,NSOIL,              &
             stc,smc,qfx,sh2ox,snodep,weasd,fx,etpx,  &
             t1,etax,etakin,CMC,SOILHX,CHX,RUNOFF1X,  &
             RUNOFF2X,RUNOFF3X,EDIRX,ECX,ETTX,RCX,HX, &
             SMCMAX1,SMCREF1,SMCWLT1,ALBEDX,ACRAIN,   &
             ACSNOM,ESNOW2D,DRIP2D,DEWFALL,SOILMX,    &
             SHORT,FPAR,                              &
             SFCHEADRT,INFXSWGT,SH2OWGT,ETPNDX,INFXSRT,&
             CHANRTSWCRT,&
#ifdef MPP_LAND
             nlinks_index,mpp_nlinks,lake_index,&
#endif
             nlinks,HLINK,CVOL,RESHT,QLAKEO, &
             LAKE_INFLORT,QSTRMVOLRT, &
             GWBASESWCRT,z_gwsubbas,ix,jx,ixrt,jxrt,numbasns)

!yw following output will not needed any more
#ifdef NNNN

#ifdef MPP_LAND
     if(IO_id.eq.my_id) then
#endif
        open(36, file="yw_"//olddate(1:16)//".txt", form='unformatted', action='write')
#ifdef MPP_LAND
    endif
#endif

#ifdef MPP_LAND
          ywtmp = QSTRMVOLRT*DXRT*DXRT/1000.  !units (m^3)
          call write_restart_rt_2(36,ywtmp)
          ywtmp = LAKE_INFLORT*DXRT*DXRT/1000.!units (m^3)
          call write_restart_rt_2(36,ywtmp)
#else
          ywtmp = QSTRMVOLRT*DXRT*DXRT/1000.  !units (m^3)
          write (36) ywtmp
          ywtmp = LAKE_INFLORT*DXRT*DXRT/1000.!units (m^3)
          write (36) ywtmp
#endif
        close(36)

#endif

#ifdef MPP_LAND
  flag  = -1
  if(my_id.eq.IO_id) then
      if (history_output) flag =99
  end if
  call mpp_land_bcast_int1(flag)
#ifdef COUPLED
  flag  = -1
#endif
  if(flag .eq. 99) then
       call mpp_output_hrldas(.true.,global_nx,global_ny,ounit, igrid, &
          split_output_count, hgrid, range, ix, jx, &
           nsoil, sldpth, startdate, olddate,  &
           vegtyp, soltyp, t1, cmc, stc, smc, sh2ox, soilmx, runoff1x, runoff2x, &
            runoff3x, etax, etakin, ecx, edirx, ettx, albedx, weasd, acrain, acsnom, &
           esnow2d, drip2d, dewfall, snodep, fpar, hx, qfx, short, infxsrt, prcp_out, &
           etpndx,sfcheadrt,smcmax1,wrfsi_static_flnm,FORC_TYP)

        if (HIRES_OUT.ge.1 .and. (SUBRTSWCRT.eq. 1 .or. OVRTSWCRT .eq. 1)) then
          call mpp_output_rt(igrid, split_output_count, &
          ixrt, jxrt, g_ixrt, g_jxrt, nsoil, &
          trim(startdate), trim(olddate), QSUBRT,ZWATTABLRT,SMCRT,SUB_RESID,       &
          q_sfcflx_x,q_sfcflx_y,soxrt,soyrt,QSTRMVOLRT,SFCHEADSUBRT, &
          trim(wrfsi_finegrid_flnm),DT,SLDPTH, latval, lonval,DXRT,HIRES_OUT)
        end if

          if (CHANRTSWCRT.eq.1.or.CHANRTSWCRT.eq.2) then 
            call mpp_output_chrt(igrid, split_output_count, NLINKS, ORDER, &
            startdate, olddate, CHLON,CHLAT, HLINK, ZELEV,QLINK,DT, &
            mpp_nlinks,nlinks_index,K,STRMFRXSTPTS)

            if (NLAKES.gt.0) then 
              call mpp_output_lakes(igrid, split_output_count, NLAKES, &
              startdate, olddate, LATLAKE,LONLAKE,ELEVLAKE,QLAKEI, QLAKEO, &
              RESHT,DT,lake_index,K)
             end if

           end if

     end if
#else 
     if (history_output) then
     print*, "output_hrldas .............."
     call output_hrldas(ounit, igrid, split_output_count,      &
          hgrid, range, ix, jx,                                &
          nsoil, sldpth, startdate, olddate,                &
          vegtyp, soltyp, t1, cmc, stc, smc, sh2ox, soilmx,    &
          runoff1x, runoff2x,                                  &
          runoff3x, etax, etakin, ecx, edirx, ettx, albedx,    &
          weasd, acrain, acsnom,                               &
          esnow2d, drip2d, dewfall, snodep, fpar, hx, qfx,     &
          short, infxsrt, prcp_out,                            &
          etpndx,sfcheadrt,smcmax1,wrfsi_static_flnm,FORC_TYP)

        if (HIRES_OUT.ge.1) then
          call output_rt(igrid, split_output_count, ixrt, jxrt, nsoil, &
          startdate, olddate, QSUBRT,ZWATTABLRT,SMCRT,SUB_RESID,       &
          q_sfcflx_x,q_sfcflx_y,soxrt,soyrt,QSTRMVOLRT,SFCHEADSUBRT, &
          wrfsi_finegrid_flnm,DT,SLDPTH,LATVAL,LONVAL,DXRT,HIRES_OUT)

        end if


        if (CHANRTSWCRT.eq.1.or.CHANRTSWCRT.eq.2) then 

          call output_chrt(igrid, split_output_count, NLINKS,ORDER, &
          startdate,olddate,CHLON,CHLAT, HLINK, ZELEV,QLINK,DT,K, &
          STRMFRXSTPTS)

         if (NLAKES.gt.0) then 
          call output_lakes(igrid, split_output_count, NLAKES, &
          startdate, olddate, LATLAKE,LONLAKE,ELEVLAKE,QLAKEI, QLAKEO, &
          RESHT,DT,K)
         end if

        end if
     endif

#endif

! This variable will be accumulated.
! reset the variable to be zero for sub-surface routing.
           QSUBRT=0. 
           SOLDRAIN=0.

!------------------------------------------------------------------------
! End of Time Loop  (do K) 
!------------------------------------------------------------------------

 ENDDO KLOOP
    return

!------------------------------------------------------------------------
! Close channel routing files if activated 
!------------------------------------------------------------------------

!  IF (CHANRTSWCRT.EQ.1) THEN
!         close(38)
!         close(39)
!         close(37)
!         close(43)
!  END IF



!------------------------------------------------------------------------
!DJG End of Simulation Mass Balance Calculation
!------------------------------------------------------------------------
!------------------------------------------------------------------------
	print *, "Domain Averaged Mass Balance Information:"
        smc_final=0.
        do i=1,IX
          do j=1,JX
!           if (vegtyp(i,j).ne.16) then
            dcmc=dcmc+(cmc_init(i,j)-cmc(i,j))/(IX*JX)
            dswe=dswe+(swe_init(i,j)-weasd(i,j))/(IX*JX)
            smc_final=smc_final+(SMC(I,J,1)*100+SMC(I,J,2)*300   &
                +SMC(I,J,3)*300+SMC(I,J,4)*300+SMC(I,J,5)*300 &
                +SMC(I,J,6)*300+SMC(I,J,7)*300+SMC(I,J,8)*100) &
                /(IX*JX)
	    dacrain=dacrain+acrain(i,j)/(IX*JX)
	    dsfcevp=dsfcevp+etax(i,j)/(IX*JX)
	    dcanevp=dcanevp+ecx(i,j)/(IX*JX)
	    dedir=dedir+edirx(i,j)/(IX*JX)
	    dett=dett+ettx(i,j)/(IX*JX)
	    depnd=depnd+etpndx(i,j)/(IX*JX)
	    desno=desno+esnow2d(i,j)/(IX*JX)
            dsfcrnff=dsfcrnff+runoff1x(i,j)/(IX*JX)
            dug1rnff=dug1rnff+runoff2x(i,j)/FLOAT(IX*JX)
            dug2rnff=dug2rnff+runoff3x(i,j)/FLOAT(IX*JX)
            IF (SUBRTSWCRT.EQ.1.OR.OVRTSWCRT.EQ.1) THEN
             suminfxs1=suminfxs1+SFCHEADRT(I,J)/FLOAT(IX*JX)
            ELSE
             suminfxs1=suminfxs1+INFXSRT(I,J)/FLOAT(IX*JX)
            END IF
!           else
!             vegct=vegct+1
!           end if
          end do
        end do
        dsmctot=smc_final-smc_init

        IF (SUBRTSWCRT.EQ.1.OR.OVRTSWCRT.EQ.1) THEN
          resid1=dacrain-dsfcevp-dsmctot-dcmc-suminfxs1 &
                   -dug1rnff-dug2rnff-chan_in2-lake_in2
        ELSE
          resid1=dacrain-dsfcevp-dsmctot &
                   -dcmc-dsfcrnff-dug1rnff-dug2rnff
        END IF


!DJG Output Change in state variables:
        print *, "Change in State Variables (mm):"
	print * 
 	print *, "Change in Total Column Soil Water: ", dsmctot,   &
                     smc_final,smc_init
	print *, "Remaining Sfc Head (routing only):", suminfxs1
 	print *, "Change in Canopy Water: ", dcmc
 	print *, "Change in Snow Water Eq.: ", dswe
       
 
!DJG Output accumulation variables:
        print *, "Accumulation Terms (mm):"
        print *, 'Precipitation:', dacrain
	print *, 'Sfc Evap:', dsfcevp
	print *, 'Can Evap:', dcanevp
	print *, 'Direct Evap:', dedir
	print *, 'Transpir. :', dett
	print *, 'Ponded Evap:', depnd
	print *, 'Snow Evap:', desno
	print *, 'Sfc Runoff:', dsfcrnff
	print *, 'Ugr Runoff:', dug2rnff
	print *, 'Chan_Inflo:', chan_in2
	print *, 'Lake_Inflo:', lake_in2
        print *, '!!! Simulation Mass Balance Residual:', resid1

!	print *, 'SLOPETYP: ', SLOPETYP
!	print *, 'Accumulated infiltration excess: ', INFXSRTOT
!	print *, 'Accumulated Runoff 1: ', RNOF1TOT
!	print *, 'Accumulated Runoff 2: ', RNOF2TOT
!	print *, 'Accumulated Runoff 3: ', RNOF3TOT
!	print *, 'Total lake inflow...(m^3): ', LAKE_INFLOTRT*DXRT*DXRT/1000.
!	print *, 'Total stream inflow + storage...(m^3): ', QSTRMVOLTRT*DXRT*DXRT/1000.
!	print *, 'Total stream outflow...(m^3): ', QSTRMVOLTRT*DXRT*DXRT/1000.

        print *, 'Total flow out across domain boundary...(mm):',QBDRYTRT
!        print *, 'Total subsfc flow out across domain boundary...(mm):',   &
!                          QSUBBDRYTRT/DXRT/DXRT*DT*1000.
!        print *, 'Total subsfc flow out seepage face to stream:'   ! (not yet implemented)

!------------------------------------------------------------------------
!DJG End of Simulation Mass Balance Calculation
!------------------------------------------------------------------------


!------------------------------------------------------------------------
!DJG Dump streamflow and lake accumulation grids to files...
!------------------------------------------------------------------------
   
#ifdef MPP_LAND
       if(my_id.eq.io_id) then
#endif
         open (unit=36,file='lake_flo_last.txt',status='replace',   &
                 form='unformatted')
#ifdef MPP_LAND
       endif
#endif
!        print *, "IXRT=",ixrt,"  JXRT=",jxrt
!          write (35,*) (QSTRMVOLRT(i,j)*DXRT*DXRT/1000.,i=1,ixrt)   !units (m^3)
!          write (36,*) (LAKE_INFLORT(i,j)*DXRT*DXRT/1000.,i=1,ixrt)   !units (m^3)
#ifdef MPP_LAND
          ywtmp = QSTRMVOLRT*DXRT*DXRT/1000
          call write_restart_rt_2(36,ywtmp)
          ywtmp = LAKE_INFLORT*DXRT*DXRT/1000.
          call write_restart_rt_2(36,ywtmp)
#else
          ywtmp = QSTRMVOLRT*DXRT*DXRT/1000
          write(36) ywtmp 
          ywtmp = LAKE_INFLORT*DXRT*DXRT/1000.
          write(36) ywtmp 
#endif
         close(36)

!DJG Dump lake inflo accumulation grid into file...


!       do j=1,jxrt
!         do i=1,ixrt
!           if (LAKE_INFLORT(i,j).gt.0.) then
!             LAKE_CT = LAKE_CT+1
!           end if
!           if (QSTRMVOLRT(i,j).gt.0.) then
!             STRM_CT = STRM_CT+1
!	    end if
!         end do
!       end do

!       print *,  "No. of Stream channel grid cells receiving water :",STRM_CT 
!       print *,  "No. of Open Water Grid cells recieving water :", LAKE_CT
!       print *,  "No. of Open Water Grid Cells :,",vegct

!yw  ENDDO KLOOP
     return
     end  subroutine run_rt_land 


end module module_rtland


     subroutine land_finish()
#ifdef MPP_LAND
         call mpp_land_finish()
#else 
         stop
#endif
     return
     end  subroutine land_finish  

      subroutine output_nc(array,idim,jdim, var_name,file_name)
      implicit none
#include <netcdf.inc>
          integer idim,jdim
          real array(idim,jdim)
          integer dim(2)
          character(len=*):: file_name,var_name
          integer   iret,ncid,varid,idim_id,jdim_id
          integer i,j
          iret = nf_create(trim(file_name), 0, ncid)
          iret = nf_def_dim(ncid, "idim", idim,idim_id)
          iret = nf_def_dim(ncid, "jdim", jdim,jdim_id)
          dim(1)=idim_id
          dim(2)=jdim_id
          iret = nf_put_att_real(ncid, NF_GLOBAL, &
              "missing_value", NF_FLOAT, 1, -1.E33)

          iret = nf_def_var(ncid,var_name,NF_FLOAT,2,dim,varid)
          iret = nf_enddef(ncid)

!   output
          iret = nf_inq_varid(ncid,var_name,varid)
          iret = nf_put_var_real(ncid,varid,array)
          iret=nf_close(ncid)
      return
      end subroutine output_nc

    subroutine time_seconds(i3)
          integer time_array(8)
          real i3
          call date_and_time(values=time_array)
          i3 = time_array(5) * 3600 + time_array(6) * 60 + &
                time_array(7) + 0.001 * time_array(8)
    return
    end subroutine time_seconds

    subroutine flush( i)
      integer i
    return
    end subroutine flush

