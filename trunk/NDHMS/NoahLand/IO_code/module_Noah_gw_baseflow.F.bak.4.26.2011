MODULE module_Noah_gw_baseflow
#ifdef MPP_LAND
   use module_mpp_land
#endif

  IMPLICIT NONE

  contains

!------------------------------------------------------------------------------
!DJG   Simple GW Bucket Model
!------------------------------------------------------------------------------

   subroutine simp_gw_buck(ix,jx,ixrt,jxrt,numbasns,DX,&
                            gwsubbasmsk, runoff2x, z_gwsubbas, qin_gwsubbas,&
                            qout_gwsubbas,qinflowbase,gw_strm_msk,gwbas_pix_ct,DXRT,DT,&
                            C,ex,z_mx)
   implicit none
   
!!!Declarations...
   integer, intent(in)                               :: ix,jx,ixrt,jxrt
   integer, intent(in)                               :: numbasns
   integer, intent(in), dimension(ix,jx)             :: gwsubbasmsk
   real, intent(in), dimension(ix,jx)                :: runoff2x 
   real, intent(in)                                  :: DX,DXRT,DT
   real, intent(in),dimension(numbasns)              :: C,ex,z_mx
   real, intent(out),dimension(numbasns)             :: qout_gwsubbas
   real, intent(out),dimension(numbasns)             :: qin_gwsubbas
   real, intent(out),dimension(numbasns)             :: z_gwsubbas
   real, intent(out),dimension(ixrt,jxrt)            :: qinflowbase
   integer, intent(in),dimension(ixrt,jxrt)            :: gw_strm_msk

   real*8, dimension(numbasns)                        :: sum_perc8,ct_bas8
   real, dimension(numbasns)                        :: sum_perc
   real, dimension(numbasns)                        :: net_perc

   real, dimension(numbasns)                        :: ct_bas
   real, dimension(numbasns)                        :: gwbas_pix_ct
   integer                                          :: i,j,bas
   real                                             :: zbastmp
   character(len=19)				    :: header
   character(len=1)				    :: jnk


!!!Initialize variables...
   ct_bas8 = 0
   sum_perc8 = 0.
   net_perc = 0.
   qout_gwsubbas = 0.
   qin_gwsubbas = 0.

!   C(1) = 1.6976
!   C(2) = 2.2581
!   C(3) = 0.9342
!   C(4) = 1.3884

!   ex(1) = 0.0806
!   ex(2) = 0.0856
!   ex(3) = 0.0585
!   ex(4) = 0.0773

!!!Calculate aggregated percolation from deep runoff into GW basins...
   do i=1,ix
     do j=1,jx
       do bas=1,numbasns
         if(gwsubbasmsk(i,j).eq.bas) then
           sum_perc8(bas) = sum_perc8(bas)+runoff2x(i,j)  !runoff2x in (mm)
           ct_bas8(bas) = ct_bas8(bas) + 1
         end if
       end do
     end do
   end do

#ifdef MPP_LAND
!  print*, "step 1 "
!  write(20+my_id,*) sum_perc8
!  write(20+my_id,*) ct_bas8   
   call sum_real8(sum_perc8,numbasns)
   call sum_real8(ct_bas8,numbasns)
#endif
   sum_perc = sum_perc8
   ct_bas = ct_bas8
   
!  if(my_id.eq.IO_id) print*, "step 2, sum_perc , ct_bas,  ", sum_perc , ct_bas
!  call land_finish()


!!!Loop through GW basins to adjust for inflow/outflow

   DO bas=1,numbasns     ! Loop for GW bucket calcs...
#ifdef MPP_LAND
     if(ct_bas(bas) .gt. 0) then
#endif

     net_perc(bas) = sum_perc(bas) / ct_bas(bas)   !units (mm)
     qin_gwsubbas(bas) = net_perc(bas)/1000. * ct_bas(bas) * DX * DX !units (m^3)

!Adjust level of GW depth...(conceptual GW bucket units (m))
!     print *, "GW_Debug...Input GW basin levels...",z_gwsubbas
     z_gwsubbas(bas) = z_gwsubbas(bas) + net_perc(bas) / 1000.0   ! (m)
     zbastmp = z_gwsubbas(bas)

!Calculate baseflow as a function of GW depth...

! Assuming a steady-state (inflow=outflow) model...
!     qout_gwsubbas(bas) = qin_gwsubbas(bas)  !steady-state model...(m^3)
!     qout_gwsubbas(bas) = qout_gwsubbas(bas)/DT  !.djust for flux units...(m^3/s)

! Assuming and exponential relation between z and Q...
!     qout_gwsubbas(bas) = C(bas)*EXP(ex(bas)*z_gwsubbas(bas)) !Exp.model. q_out (m^3/s)
     qout_gwsubbas(bas) = C(bas)*EXP(ex(bas)*z_gwsubbas(bas)/z_mx(bas)) !Exp.model. q_out (m^3/s)

!Adjust level of GW depth...
     z_gwsubbas(bas) = z_gwsubbas(bas) - qout_gwsubbas(bas)*DT &
                       / (ct_bas(bas)*DX*DX)   !units(m)

!        print *, "GW_Debug...", bas,net_perc(bas),qin_gwsubbas(bas),zbastmp,&
!                 qout_gwsubbas(bas),z_gwsubbas(bas),gwbas_pix_ct(bas)
!        print *, "Estimated per pixel inflow value (mm)...", &
!           qout_gwsubbas(bas)*1000.*DT/ gwbas_pix_ct(bas)/DXRT/DXRT

#ifdef MPP_LAND
     endif
#endif
   END DO                 ! End loop for GW bucket calcs...



!!!Distribute basin integrated baseflow to stream pixels...

      qinflowbase = 0.

      do i=1,ixrt
        do j=1,jxrt
!!!    -simple uniform disaggregation (8.31.06)
           if (gw_strm_msk(i,j).gt.0) then
             qinflowbase(i,j) = qout_gwsubbas(gw_strm_msk(i,j))*1000.*DT/ &
                gwbas_pix_ct(gw_strm_msk(i,j))/DXRT/DXRT !(mm)
           end if
        end do
      end do


!!!    - weighted redistribution...(need to pass accum weights (slope) in...)
!        NOT FINISHED just BASIC framework...
!         do bas=1,numbasns
!           do k=1,gwbas_pix_ct(bas)
!             qinflowbase(i,j) = k*slope
!           end do
!         end do

   return

!------------------------------------------------------------------------------
   End subroutine simp_gw_buck
!------------------------------------------------------------------------------


!------------------------------------------------------------------------------
!DJG   Wedge-Aquifer Scheme (TBA)
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
!DJG   TOPMODEL Scheme (TBA)
!------------------------------------------------------------------------------
#ifdef MPP_LAND
   subroutine pix_ct_1(in_gw_strm_msk,ixrt,jxrt,gwbas_pix_ct,numbasns)
      USE module_mpp_land
      implicit none
      integer ::    i,j,ixrt,jxrt,numbasns, bas
      integer,dimension(ixrt,jxrt) :: in_gw_strm_msk
      integer,dimension(global_rt_nx,global_rt_ny) :: gw_strm_msk
      real,dimension(numbasns) :: gwbas_pix_ct 

      gw_strm_msk = 0
      call write_IO_rt_int(in_gw_strm_msk, gw_strm_msk)    

      if(my_id .eq. IO_id) then
         gwbas_pix_ct = 0.
         do bas = 1,numbasns  
         do i=1,global_rt_nx
           do j=1,global_rt_ny
             if(gw_strm_msk(i,j) .eq. bas) then
                gwbas_pix_ct(gw_strm_msk(i,j)) = gwbas_pix_ct(gw_strm_msk(i,j)) &
                     + 1.0
             endif
           end do
         end do
         end do
      end if
      call mpp_land_bcast_real(numbasns,gwbas_pix_ct)

      return
   end subroutine pix_ct_1
#endif
   
END MODULE module_Noah_gw_baseflow 
